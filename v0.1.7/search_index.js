var documenterSearchIndex = {"docs":
[{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicDynamics.jl/blob/master/examples/Cyber-Physical.jl\"","category":"page"},{"location":"examples/Cyber-Physical/#cyberphysical_example","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"","category":"section"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"(Image: )","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"Authors: Georgios Bakirtzis https://bakirtzis.net/ and Raul Gonzalez Garcia (raulg@iastate.edu)","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"The following example is a mechanization from","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"Compositional Cyber-Physical Systems Modeling - http://dx.doi.org/10.4204/EPTCS.333.9\nCategorical Semantics of Cyber-Physical Systems Theory - https://doi.org/10.1145/3461669","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"using AlgebraicDynamics\nusing AlgebraicDynamics.DWDDynam\n\nusing Catlab.WiringDiagrams\nusing Catlab.Graphics\nusing Catlab.Graphics.Graphviz\n\nusing LabelledArrays\nusing DifferentialEquations\nusing Plots","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"We use  functorial semantics to model a cyper-physical system, namely an unmanned aerial vehicle (UAV). We define a diagram of systems (the composition syntax) that is the architecture of the composition. Then, we apply behaviors of the individual parts of the system to the architecture. This composition produces a complete UAV model.","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"We first have to define our boxes and specify what the inports and outports are. For example, the sensor box has two inports :e and :s and one outport s_prime.","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"s = Box(:sensor, [:s, :e], [:sâ€²])\nc = Box(:controller, [:d, :sâ€²], [:c])\nd = Box(:dynamics, [:c], [:s]);\nnothing #hide","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"A wiring diagram has outer inports and outports which define the interface of target system. Then we add the boxes and wires to the diagram and visualize the result.","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"UAV = WiringDiagram([:e,:d], [:s])\n\nsensor     = add_box!(UAV, s)\ncontroller = add_box!(UAV, c)\ndynamics   = add_box!(UAV, d)\n\nadd_wires!(UAV, [\n    # net inputs\n    (input_id(UAV), 1) => (sensor, 2),\n    (input_id(UAV), 2) => (controller, 2),\n\n    # connections\n    (sensor, 1) => (controller, 1),\n    (controller, 1) => (dynamics, 1),\n    (dynamics, 1) => (sensor, 1),\n\n    # net output\n    (dynamics, 1) => (output_id(UAV), 1)\n]);\nnothing #hide","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"to_graphviz(UAV)","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"Then we assign behaviors to inhabit the boxes.","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"function ð—Ÿ(ð–)\n    ð¿(u, x, p, t) = [ -p.ð“l * (u[1] - x[1] - x[2]) ] # sc\n    ð¶(u, x, p, t) = [ -p.ð“c * (u[1] + p.ð“‘c*x[1] - x[2]) ] # sl\n    ð·(u, x, p, t) = LVector(Î± = -0.313*u[1] +  56.7*u[2] +  0.232*x[1],\n                             q = -0.013*u[1] - 0.426*u[2] + 0.0203*x[1],\n                             Î¸ =  56.7*u[2]              )\n\n    u_ð¿(u,p,t) = [ u[1] ] # outputs sl\n    u_ð¶(u,p,t) = [ u[1] ] # outputs sc\n    u_ð·(u,p,t) = [ u[3] ] # outputs Î¸\n\n    return oapply(ð–,\n                  Dict(:sensor     => ContinuousMachine{Float64}(2, 1, 1, ð¿, u_ð¿),\n                       :controller => ContinuousMachine{Float64}(2, 1, 1, ð¶, u_ð¶),\n                       :dynamics   => ContinuousMachine{Float64}(1, 3, 1, ð·, u_ð·)))\nend\n\nð‘¢áµ¤â‚áµ¥ = ð—Ÿ(UAV)","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"Lastly, we compute and plot the solution.","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"# initial values\nxâ‚’ = LVector( e = 0.01,  # [e, d] -> [Î¸ offset, ð›¿ control input]\n              d = 0.05);\n\nuâ‚’ = [0.0, 0, 0, 0, 0]\ntspan = (0, 20.0)\n\nparams = (ð“l = 100,  # decay constant of sensor\n          ð“c = 100,  # decay constant of controller\n          ð“‘c = 0)    # ratio of velocity to reference velocity\n\nprob = ODEProblem(ð‘¢áµ¤â‚áµ¥, uâ‚’, xâ‚’, tspan, params)\nsol = solve(prob, alg_hints=[:stiff]);\nnothing #hide","category":"page"},{"location":"examples/Cyber-Physical/","page":"Cyber Physical Systems Example","title":"Cyber Physical Systems Example","text":"plot(sol, vars = [1,2, ((t,y) -> (t, y*1e2), 0, 4), 3, 5],\n    label = [\"sl\" \"sc\" \"Î±\" \"q\" \"Î¸\"],\n    lw = 2, title  = \"Aircraft pitch behaviour\",\n    xlabel = \"time\", ylabel = \"response\"\n)","category":"page"},{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#Types-of-Dynamical-Systems","page":"Library Reference","title":"Types of Dynamical Systems","text":"","category":"section"},{"location":"api/#Machines","page":"Library Reference","title":"Machines","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"AlgebraicDynamics.DWDDynam.AbstractMachine\nAlgebraicDynamics.DWDDynam.ContinuousMachine\nAlgebraicDynamics.DWDDynam.DelayMachine\nAlgebraicDynamics.DWDDynam.DiscreteMachine","category":"page"},{"location":"api/#AlgebraicDynamics.DWDDynam.AbstractMachine","page":"Library Reference","title":"AlgebraicDynamics.DWDDynam.AbstractMachine","text":"Machine{T}\nMachine{T,N}\n\nA directed open dynamical system operating on information of type T. For type arguments {T,N}, the system operates on arrays of type T and ndims = N. A machine  m has type signature  (m.ninputs, m.noutputs).\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicDynamics.DWDDynam.ContinuousMachine","page":"Library Reference","title":"AlgebraicDynamics.DWDDynam.ContinuousMachine","text":"ContinuousMachine{T}(ninputs, nstates, noutputs, f, r)\n\nA directed open continuous system. The dynamics function f defines an ODE dot u(t) = f(u(t)x(t)pt), where u is the state and x captures the exogenous variables.\n\nThe readout function r may depend on the state, parameters and time, so it must be of the form r(upt). If it is left out, then r=u.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicDynamics.DWDDynam.DelayMachine","page":"Library Reference","title":"AlgebraicDynamics.DWDDynam.DelayMachine","text":"DelayMachine{T}(ninputs, nstates, noutputs, f, r)\n\nA delay open continuous system. The dynamics function f defines an ODE dot u(t) = f(u(t) x(t) h(pt) p t), where u is the state, x captures the exogenous variables, and h is a history function.\n\nThe readout function r may depend on the state, history, parameters and time, so it has the signature r(uhpt). If it is left out, then r=u.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicDynamics.DWDDynam.DiscreteMachine","page":"Library Reference","title":"AlgebraicDynamics.DWDDynam.DiscreteMachine","text":"DiscreteMachine{T}(ninputs, nstates, noutputs, f, r)\n\nA directed open discrete dynamical system. The dynamics function f defines a discrete update rule u_n+1 = f(u_n x_n p t), where u_n is the state and x_n is the value of the exogenous variables at the nth time step.\n\nThe readout function r may depend on the state, parameters and time step, so it must be of the form r(u_npn). If it is left out, then r_n=u_n.\n\n\n\n\n\n","category":"type"},{"location":"api/#Resource-Sharers","page":"Library Reference","title":"Resource Sharers","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"AlgebraicDynamics.UWDDynam.AbstractResourceSharer\nAlgebraicDynamics.UWDDynam.ContinuousResourceSharer\nAlgebraicDynamics.UWDDynam.DelayResourceSharer\nAlgebraicDynamics.UWDDynam.DiscreteResourceSharer","category":"page"},{"location":"api/#AlgebraicDynamics.UWDDynam.AbstractResourceSharer","page":"Library Reference","title":"AlgebraicDynamics.UWDDynam.AbstractResourceSharer","text":"ResourceSharer{T}\nResourceSharer{T,N}\n\nAn undirected open dynamical system operating on information of type T. For type arguments {T,N}, the system operates on arrays of type T and ndims = N. A resource sharer r has type signature r.nports.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicDynamics.UWDDynam.ContinuousResourceSharer","page":"Library Reference","title":"AlgebraicDynamics.UWDDynam.ContinuousResourceSharer","text":"ContinuousResourceSharer{T}(nports, nstates, f, portmap)\n\nAn undirected open continuous system. The dynamics function f defines an ODE dot u(t) = f(u(t)pt).\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicDynamics.UWDDynam.DelayResourceSharer","page":"Library Reference","title":"AlgebraicDynamics.UWDDynam.DelayResourceSharer","text":"DelayResourceSharer{T}(nports, nstates, f, portmap)\n\nAn undirected open continuous system. The dynamics function f defines a DDE dot u(t) = f(u(t)h(t)pt), where h is a function giving the history of the system's state u before the interval on which the solution will be computed begins (usually for t  0). f should have signature f(uhpt), where h is a function.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicDynamics.UWDDynam.DiscreteResourceSharer","page":"Library Reference","title":"AlgebraicDynamics.UWDDynam.DiscreteResourceSharer","text":"DiscreteResourceSharer{T}(nports, nstates, f, portmap)\n\nAn undirected open discrete system. The dynamics function f defines a discrete update rule u_n+1 = f(u_n p t).\n\n\n\n\n\n","category":"type"},{"location":"api/#Composition-of-Dynamical-Systems","page":"Library Reference","title":"Composition of Dynamical Systems","text":"","category":"section"},{"location":"api/#Operad-Algebras","page":"Library Reference","title":"Operad Algebras","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"AlgebraicDynamics.UWDDynam.oapply","category":"page"},{"location":"api/#Catlab.WiringDiagrams.WiringDiagramAlgebras.oapply","page":"Library Reference","title":"Catlab.WiringDiagrams.WiringDiagramAlgebras.oapply","text":"oapply(d::WiringDiagram, ms::Vector{M}) where {M<:AbstractMachine}\n\nImplements the operad algebras for directed composition of dynamical systems, given a composition pattern (implemented by a directed wiring diagram d) and primitive systems (implemented by a collection of  machines ms). Returns the composite machine.\n\nEach box of the composition pattern d must be filled by a machine with the appropriate type signature.\n\n\n\n\n\noapply(d::WiringDiagram, m::AbstractMachine)\n\nA version of oapply where each box of d is filled with the same machine m.\n\n\n\n\n\noapply(d::WiringDiagram, generators::AbstractDict{S,M}) where {S,M<:AbstractMachine}\n\nA version of oapply where generators is a dictionary mapping the name of each box to its corresponding machine. \n\n\n\n\n\n oapply(d::AbstractUWD, rs::Vector{R}) where {R<:AbstractResourceSharer}\n\nImplements the operad algebras for undirected composition of dynamical systems, given a composition pattern (implemented by an undirected wiring diagram d) and primitive systems (implemented by a collection of resource sharers rs). Returns the composite resource sharer.\n\nEach box of d must be filled by a resource sharer of the appropriate type signature. \n\n\n\n\n\noapply(d::AbstractUWD, r::AbstractResourceSharer)\n\nA version of oapply where each box of d is filled with the same resource sharer r.\n\n\n\n\n\n oapply(d::AbstractUWD, generators::AbstractDict{S,R}) where {S,R<:AbstractResourceSharer}\n\nA version of oapply where generators is a dictionary mapping the name of each box to its corresponding resource sharer.\n\n\n\n\n\noapply(d::OpenCPortGraph, ms::Vector{M}) where {M<:AbstractMachine}\n\nImplements the operad algebras for directed composition of dynamical systems, given a composition pattern (implemented by an open circular port graph d) and primitive systems (implemented by a collection of  machines ms). Returns the composite machine.\n\nEach box of the composition pattern d must be filled by a machine with the appropriate type signature.\n\n\n\n\n\noapply(d::OpenCPortGraph, m::AbstractMachine)\n\nA version of oapply where each box of d is filled with the same machine m.\n\n\n\n\n\n","category":"function"},{"location":"api/#Checks","page":"Library Reference","title":"Checks","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"AlgebraicDynamics.UWDDynam.fills\nAlgebraicDynamics.DWDDynam.fills","category":"page"},{"location":"api/#AlgebraicDynamics.UWDDynam.fills","page":"Library Reference","title":"AlgebraicDynamics.UWDDynam.fills","text":"fills(r::AbstractResourceSharer, d::AbstractUWD, b::Int)\n\nChecks if r is of the correct signature to fill box b of the undirected wiring diagram d.\n\n\n\n\n\nfills(m::AbstractMachine, d::OpenCPortGraph, b::Int)\n\nChecks if m is of the correct signature to fill box b of the open CPG d.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDynamics.DWDDynam.fills","page":"Library Reference","title":"AlgebraicDynamics.DWDDynam.fills","text":"fills(m::AbstractMachine, d::WiringDiagram, b::Int)\n\nChecks if m is of the correct signature to fill box b of the wiring diagram d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Time-Evolution","page":"Library Reference","title":"Time Evolution","text":"","category":"section"},{"location":"api/#Instantaneous-Dynamics","page":"Library Reference","title":"Instantaneous Dynamics","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"AlgebraicDynamics.UWDDynam.eval_dynamics","category":"page"},{"location":"api/#AlgebraicDynamics.UWDDynam.eval_dynamics","page":"Library Reference","title":"AlgebraicDynamics.UWDDynam.eval_dynamics","text":"eval_dynamics(m::AbstractMachine, u::AbstractVector, x:AbstractVector{F}, p, t) where {F<:Function}\neval_dynamics(m::AbstractMachine{T}, u::AbstractVector, x:AbstractVector{T}, p, t) where T\n\nEvaluates the dynamics of the machine m at state u, parameters p and time t. The exogenous variables are set by x, which may be a collection either of functions x_i(t) or of constant values. In either case, the length of x must equal the number of inputs to m.\n\n\n\n\n\neval_dynamics(r::AbstractResourceSharer, u::AbstractVector, p, t)\n\nEvaluates the dynamics of the resource sharer r at state u, parameters p and time t. Omitting p and t is allowed if the dynamics of r does not depend on them.\n\n\n\n\n\n","category":"function"},{"location":"api/#Time-Discretization","page":"Library Reference","title":"Time Discretization","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"AlgebraicDynamics.UWDDynam.euler_approx","category":"page"},{"location":"api/#AlgebraicDynamics.UWDDynam.euler_approx","page":"Library Reference","title":"AlgebraicDynamics.UWDDynam.euler_approx","text":"euler_approx(m::ContinuousMachine, h::Float)\n\nTransforms a continuous machine m into a discrete machine via Euler's method with step size h. If the dynamics of m is given by dotu(t) = f(u(t)x(t)pt), then the dynamics of the new discrete system is given by the update rule u_n+1 = u_n + h f(u_n x_n p t).\n\n\n\n\n\neuler_approx(m::ContinuousMachine)\n\nTransforms a continuous machine m into a discrete machine via Euler's method. The step size parameter is appended to the end of the system's parameter list.\n\n\n\n\n\neuler_approx(ms::Vector{M}, args...) where {M<:ContinuousMachine}\neuler_approx(ms::AbstractDict{S, M}, args...) where {S,M<:ContinuousMachine}\n\nMap euler_approx over a collection of machines with identical args.\n\n\n\n\n\neuler_approx(r::ContinuousResourceSharer, h::Float)\n\nTransforms a continuous resource sharer r into a discrete resource sharer via Euler's method with step size h. If the dynamics of r is given by dotu(t) = f(u(t)pt), then the dynamics of the new discrete system is given by the update rule u_n+1 = u_n + h f(u_n p t).\n\n\n\n\n\neuler_approx(r::ContinuousResourceSharer)\n\nTransforms a continuous resource sharer r into a discrete resource sharer via Euler's method. The step size parameter is appended to the end of the system's parameter list.\n\n\n\n\n\neuler_approx(rs::Vector{R}, args...) where {T,R<:ContinuousResourceSharer{T}}\neuler_approx(rs::AbstractDict{S, R}, args...) where {S,T,R<:ContinuousResourceSharer{T}}\n\nMap euler_approx over a collection of resource sharers with identical args.\n\n\n\n\n\n","category":"function"},{"location":"api/#Discrete-Trajectory","page":"Library Reference","title":"Discrete Trajectory","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"AlgebraicDynamics.UWDDynam.trajectory","category":"page"},{"location":"api/#AlgebraicDynamics.UWDDynam.trajectory","page":"Library Reference","title":"AlgebraicDynamics.UWDDynam.trajectory","text":"trajectory(m::DiscreteMachine, u0::AbstractVector, x::AbstractVector, p, nsteps::Int; dt::Int = 1)\ntrajectory(m::DiscreteMachine, u0::AbstractVector, x::AbstractVector, p, tspan::Tuple{T,T}; dt::T= one(T)) where {T<:Real}\n\nEvolves the machine m, for nsteps times or over tspan, with step size dt, initial condition u0 and parameters p. Any inputs to m are determined by x as in eval_dynamics(). If m has no inputs, then you can omit x.\n\n\n\n\n\ntrajectory(r::DiscreteResourceSharer, u0::AbstractVector, p, nsteps::Int; dt::Int = 1)\ntrajectory(r::DiscreteResourceSharer, u0::AbstractVector, p, tspan::Tuple{T,T}; dt::T= one(T)) where {T<:Real}\n\nEvolves the resouce sharer r, for nsteps times or over tspan, with step size dt, initial condition u0 and parameters p.\n\n\n\n\n\n","category":"function"},{"location":"api/#Integration-with-[DifferentialEquations.jl](https://diffeq.sciml.ai/stable/#Problem-Types)","page":"Library Reference","title":"Integration with DifferentialEquations.jl","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"AlgebraicDynamics.UWDDynam.ODEProblem\nAlgebraicDynamics.UWDDynam.DDEProblem\nAlgebraicDynamics.UWDDynam.DiscreteProblem","category":"page"},{"location":"api/#SciMLBase.ODEProblem","page":"Library Reference","title":"SciMLBase.ODEProblem","text":"ODEProblem(m::ContinuousMachine, x::Vector, u0::Vector, tspan, p=nothing; kwargs...)\n\nConstructs an ODEProblem from the vector field defined by (u,p,t) -> m.dynamics(u,x,p,t), where the exogenous variables are determined by x as in eval_dynamics().\n\n\n\n\n\nODEProblem(r::ContinuousResourceSharer, u0::Vector, tspan)\n\nConstructs an ODEProblem from the vector field defined by (u,p,t) -> r.dynamics(u,p,t).\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLBase.DDEProblem","page":"Library Reference","title":"SciMLBase.DDEProblem","text":"DDEProblem(m::DelayMachine, u0::Vector, x::Vector, h::Function, tspan, p=nothing; kwargs...)\n\nConstructs a DDEProblem from the vector field defined by (u,h,p,t) -> m.dynamics(u,x,h,p,t), where the exogenous variables are determined by x as in eval_dynamics().\n\n\n\n\n\nDDEProblem(r::DelayResourceSharer, u0::Vector, h, tspan)\n\nConstructs a DDEProblem from the vector field defined by (u,h,p,t) -> r.dynamics(u,h,p,t).\n\n\n\n\n\n","category":"type"},{"location":"api/#SciMLBase.DiscreteProblem","page":"Library Reference","title":"SciMLBase.DiscreteProblem","text":"DiscreteProblem(m::DiscreteMachine, x::Vector, u0::Vector, tspan, p=nothing; kwargs...)\n\nConstructs a DiscreteProblem from the equation of motion defined by (u,p,t) -> m.dynamics(u,x,p,t), where the exogenous variables are determined by x as in eval_dynamics(). Pass nothing in place of p if your system does not have parameters.\n\n\n\n\n\nDiscreteProblem(r::DiscreteResourceSharer, u0::Vector, p)\n\nConstructs a DiscreteProblem from the equation of motion defined by (u,p,t) -> r.dynamics(u,p,t).  Pass nothing in place of p if your system does not have parameters.\n\n\n\n\n\n","category":"type"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicDynamics.jl/blob/master/examples/Ecosystem.jl\"","category":"page"},{"location":"examples/Ecosystem/#ecosystem_example","page":"Ecosystem Models","title":"Ecosystem Models","text":"","category":"section"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"(Image: )","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"using AlgebraicDynamics\nusing AlgebraicDynamics.DWDDynam\nusing AlgebraicDynamics.UWDDynam\n\nusing Catlab.CategoricalAlgebra\nusing Catlab.WiringDiagrams\nusing Catlab.Graphics\nusing Catlab.Programs\n\nusing LabelledArrays\nusing OrdinaryDiffEq\nusing Plots, Plots.PlotMeasures","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"There will be 16 parameters in to the total ecosystem. With four distinct types:","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"parameters alpha represent the rate at which a species population grows\nparameters beta represent the rate at which a population of prey declines in a predation interaction\nparameters gamma represent the rate at which a population of predators grows in a predation interaction\nparameters delta represent the rate at with a species population declines","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"params = LVector(Î±r=0.3, Î²rf=0.015, Î³rf=0.015, Î´f=0.7,\n                 Î²rh=0.01, Î³rh=0.01, Î´h=0.5,\n                 Î³fishh=0.001, Î²fishh=0.003,\n                 Î±fish=0.35, Î²fishF=0.015, Î³fishF=0.015,\n                 Î´F=0.7, Î²Fs=0.017, Î³Fs=0.017, Î´s=0.35)","category":"page"},{"location":"examples/Ecosystem/#Land-Ecosystem","page":"Ecosystem Models","title":"Land Ecosystem","text":"","category":"section"},{"location":"examples/Ecosystem/#Rabbits-and-foxes","page":"Ecosystem Models","title":"Rabbits and foxes","text":"","category":"section"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"A standard Lotka Volterra predator-prey model is the composition of three primitive resource sharers:","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"a model of rabbit growth: this resource sharer has dynamics dot r(t) = alpha r(t) and one port which exposes the rabbit population.\na model of rabbit/fox predation: this resource sharer has dynamics dot r(t) = -beta r(t) f(t) dot f(t) = gamma r(t)f(t) and two ports which expose the rabbit and fox populations respectively.\na model of fox population decline: this resource sharer has dynamics dot f(t) = -delta f(t) and one port which exposes the fox population.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"However, there are not two independent rabbit populations â€“ one that grows and one that gets eaten by foxes. Likewise, there are not two independent fox populations â€“ one that declines and one that feasts on rabbits. To capture these interactions between the trio of resource sharers, we compose them by identifying the exposed rabbit populations and identifying the exposed fox populations. The syntax for this undirected composition is defined by an undirected wiring diagram.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Define the primitive systems\ndotr(u,p,t) = p.Î±r*u\ndotrf(u,p,t) = [-p.Î²rf*u[1]*u[2], p.Î³rf*u[1]*u[2]]\ndotf(u,p,t) = -p.Î´f*u\n\nrabbit_growth = ContinuousResourceSharer{Float64}(1, dotr)\nrabbitfox_predation = ContinuousResourceSharer{Float64}(2, dotrf)\nfox_decline = ContinuousResourceSharer{Float64}(1, dotf)\n\n# Define the composition pattern\nrabbitfox_pattern = @relation (rabbits, foxes) begin\n    rabbit_growth(rabbits)\n    rabbitfox_predation(rabbits,foxes)\n    fox_decline(foxes)\nend\n\n# Compose\nsubmodels = Dict(\n    :rabbit_growth => rabbit_growth,\n    :rabbitfox_predation => rabbitfox_predation,\n    :fox_decline => fox_decline\n)\nrabbitfox_system = oapply(rabbitfox_pattern, submodels)","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"Previously, when we derived the Lotka-Volterra model via undirected composition, we by-hand defined the undirected wiring diagram that implements the composition pattern. In contrast, here we implement the same composition pattern as before but this time using the @relation macro. This strategy simplifies the definition and explicitly names the boxes and variables. We  visualize the composition pattern below.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"to_graphviz(rabbitfox_pattern, box_labels = :name, junction_labels = :variable, edge_attrs=Dict(:len => \".75\"))","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"We can now construct an ODEProblem from the resource sharer rabbitfox_system and plot the solution.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"u0 = [10.0, 100.0]\ntspan = (0.0, 100.0)\n\nprob = ODEProblem(rabbitfox_system, u0, tspan, params)\nsol = solve(prob, Tsit5())\n\nplot(sol, rabbitfox_system,\n    lw=2,\n    title = \"Lotka-Volterra Predator-Prey Model\",\n    xlabel = \"time\", ylabel = \"population size\")","category":"page"},{"location":"examples/Ecosystem/#Rabbits,-foxes,-and-hawks","page":"Ecosystem Models","title":"Rabbits, foxes, and hawks","text":"","category":"section"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"Suppose we now have a three species ecosystem containing rabbits, foxes, and hawks. Foxes and hawks both prey upon rabbits but do not interact with each other. This ecosystem consists of five primitive systems which share variables.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"rabbit growth:  dot r(t) = alpha r(t)\nrabbit/fox predation:  dot r(t) = -beta r(t) f(t) dot f(t) = delta r(t)f(t)\nfox decline:  dot f(t) = -gamma f(t)\nrabbit/hawk predation: dot r(t) = -beta r(t)h(t) dot h(t) = delta r(t)h(t)\nhawk decline:  dot h(t) = -gamma h(t)","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"This means the desired composition pattern has five boxes and many ports and wires to keep track of. Instead of implementing this composition pattern by hand, we construct it as a pushout.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Define the composition pattern for rabbit growth\nrabbit_pattern = @relation (rabbits,) -> rabbit_growth(rabbits)\n\n# Define the composition pattern for the rabbit/hawk Lotka Volterra model\nrabbithawk_pattern = @relation (rabbits, hawks) begin\n    rabbit_growth(rabbits)\n    rabbithawk_predation(rabbits,hawks)\n    hawk_decline(hawks)\nend\n\n# Define transformations between the composition patterns\nrabbitfox_transform  = ACSetTransformation((Box=[1], Junction=[1], Port=[1], OuterPort=[1]), rabbit_pattern, rabbitfox_pattern)\nrabbithawk_transform = ACSetTransformation((Box=[1], Junction=[1], Port=[1], OuterPort=[1]), rabbit_pattern, rabbithawk_pattern)\n\n# Take the pushout to define the composition pattern for the rabbit, fox, hawk system\nrabbitfoxhawk_pattern = ob(pushout(rabbitfox_transform, rabbithawk_transform))\n\n# Visualize the compsition pattern\nto_graphviz(rabbitfoxhawk_pattern, box_labels = :name, junction_labels = :variable, edge_attrs=Dict(:len => \".9\"))","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Define the additional primitive systems\ndotrh(u, p, t) = [-p.Î²rh*u[1]*u[2], p.Î³rh*u[1]*u[2]]\ndoth(u, p, t)  = -p.Î´h*u\n\nrabbithawk_predation = ContinuousResourceSharer{Float64}(2, dotrh)\nhawk_decline         = ContinuousResourceSharer{Float64}(1, doth)\n\n# Compose\nmerge!(submodels, Dict(\n    :rabbithawk_predation => rabbithawk_predation,\n    :hawk_decline => hawk_decline\n))\n\nland_system = oapply(rabbitfoxhawk_pattern, submodels)\n\n# Solve and plot\nu0 = [10.0, 100.0, 50.0]\ntspan = (0.0, 100.0)\n\nprob = ODEProblem(land_system, u0, tspan, params)\nsol = solve(prob, Tsit5())\n\nplot(sol, land_system,\n    lw=2,\n    title = \"Land Ecosystem\",\n    xlabel = \"time\", ylabel = \"population size\")","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"Unfortunately, the hawks are going extinct in this model. We'll have to give hawks something else to eat!","category":"page"},{"location":"examples/Ecosystem/#Ocean-Ecosystem","page":"Ecosystem Models","title":"Ocean Ecosystem","text":"","category":"section"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"Consider a ocean ecosystem containing three species â€”- little fish, big fish, and sharks -â€” with two predation interactions â€”- sharks eat big fish and big fish eat little fish.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"This ecosystem can be modeled as the composition of 3 machines:","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"Evolution of the little fish population:  this machine has one exogenous variable which represents a population of predators h(t) that hunt little fish. This machine has one output which emits the little fish population. The dynamics of this machine is the driven ODE dot f(t) = alpha f(t) - beta f(t)h(t)\nEvolution of the big fish population:  this machine has two exogenous variables which represent a population of prey e(t) that are eaten by big fish and a population of predators h(t) which hunt big fish. This machine has one output which emits the big fish population. The dynamics of this machine is the drive ODE dot F(t) = gamma F(t)e(t) - delta F(t) - betaF(t)h(t)\nEvolution of the shark population:  this machine has one exogenous variable which represents a population of prey e(t) that are eaten by sharks. This machine has one output which emits the shark population. The dynamics of this machine is the driven ODE dot s(t) = gammas(t)e(t) - deltas(t)","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Define the primitive systems\ndotfish(f, x, p, t) = [p.Î±fish*f[1] - p.Î²fishF*x[1]*f[1]]\ndotFISH(F, x, p, t) = [p.Î³fishF*x[1]*F[1] - p.Î´F*F[1] - p.Î²Fs*x[2]*F[1]]\ndotsharks(s, x, p, t) = [p.Î³Fs*s[1]*x[1]-p.Î´s*s[1]]\n\nfish   = ContinuousMachine{Float64}(1,1,1, dotfish,   (f,p,t)->f)\nFISH   = ContinuousMachine{Float64}(2,1,1, dotFISH,   (F,p,t)->F)\nsharks = ContinuousMachine{Float64}(1,1,1, dotsharks, (s,p,t)->s)","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"We compose these machines by (1) sending the output of the big fish machine as the input to both the little fish and shark machines and (2) sending the output of the little fish and shark machines as the inputs to the big fish machine. The syntax for this directed composition is given by a directed wiring diagram.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Define the composition pattern\nocean_pattern = WiringDiagram([], [:fish, :Fish, :shark])\nfish_box = add_box!(ocean_pattern, Box(:fish, [:pop], [:pop]))\nFish_box = add_box!(ocean_pattern, Box(:Fish, [:pop, :pop], [:pop]))\nshark_box = add_box!(ocean_pattern, Box(:shark, [:pop], [:pop]))\n\noutput_box = output_id(ocean_pattern)\nadd_wires!(ocean_pattern, Pair[\n    (fish_box, 1)  => (Fish_box, 1),\n    (shark_box, 1) => (Fish_box, 2),\n    (Fish_box, 1)  => (fish_box, 1),\n    (Fish_box, 1)  => (shark_box, 1),\n    (fish_box, 1)  => (output_box, 1),\n    (Fish_box, 1)  => (output_box, 2),\n    (shark_box, 1) => (output_box, 3)\n])\n\n# Visualize the composition pattern\nto_graphviz(ocean_pattern, orientation=TopToBottom)","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Compose\nocean_system = oapply(ocean_pattern, [fish, FISH, sharks])\n\n# Solve and plot\nu0 = [100.0, 10, 2.0]\ntspan = (0.0, 100.0)\n\nprob = ODEProblem(ocean_system, u0, tspan, params)\nsol = solve(prob, Tsit5())\n\nplot(sol, ocean_system,\n    lw=2, title = \"Ocean Ecosystem\",\n    xlabel = \"time\", ylabel = \"population size\"\n)","category":"page"},{"location":"examples/Ecosystem/#Total-ecosystem","page":"Ecosystem Models","title":"Total ecosystem","text":"","category":"section"},{"location":"examples/Ecosystem/#Another-layer-of-composition","page":"Ecosystem Models","title":"Another layer of composition","text":"","category":"section"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"We will introduce a final predation interaction â€“ hawks eat little fish â€“  which will combine the land and ocean ecosystems. The composition will be as resource shareres so the first thing we will do is use the dynamics of the machine ocean_system to define the dynamics of a resource sharer. We will also define a resource sharer that models hawk/little fish predation.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Define the additional primitive systems\nocean_system_rs = ContinuousResourceSharer{Float64}(3, (u,p,t) -> eval_dynamics(ocean_system, u, [], p))\n\ndothf(u,p,t) = [p.Î³fishh*u[1]*u[2], -p.Î²fishh*u[1]*u[2]]\nfishhawk_predation = ContinuousResourceSharer{Float64}(2, dothf)\n\n# Define the composition pattern\neco_pattern = @relation (rabbits, foxes, hawks, littlefish, BigFish, sharks)  begin\n    turf(rabbits,foxes,hawks)\n    air(hawks, littlefish)\n    surf(littlefish, BigFish, sharks)\nend\n\n# Visualize the composition pattern\nto_graphviz(eco_pattern, box_labels = :name, junction_labels = :variable, edge_attrs=Dict(:len => \".75\"))","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Compose\n\necosystem = oapply(eco_pattern, Dict(\n    :turf => land_system,\n    :air => fishhawk_predation,\n    :surf => ocean_system_rs)\n)","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"We can now plot the evolution of the total ecosystem.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Solve and plot\nu0 = [100.0, 50.0, 20.0, 100, 10, 2.0]\ntspan = (0.0, 100.0)\n\nprob = ODEProblem(ecosystem, u0, tspan, params)\nsol = solve(prob, Tsit5())\nplot(sol, ecosystem,\n    lw=2, title = \"Total Ecosystem\",\n    xlabel = \"time\", ylabel = \"population size\"\n)","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"Let's zoom in on a narrower time-window.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"tspan = (0.0, 30.0)\n\nprob = ODEProblem(ecosystem, u0, tspan, params)\nsol = solve(prob, Tsit5())\nplot(sol, ecosystem,\n    lw=2, title = \"Total Ecosystem\",\n    xlabel = \"time\", ylabel = \"population size\"\n)","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"As a sanity check we can define the rates for the hawk/little fish predation to be 0. This decouples the land and ocean ecosystems. As expected, the plot shows the original evolution of the land ecosystem overlayed with the original evolution of the ocean ecosystem. This shows that they two ecosystems now evolve independently.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"tspan = (0.0, 100.0)\nparams.Î²fishh = 0; params.Î³fishh = 0\n\nprob = ODEProblem(ecosystem, u0, tspan, params)\nsol = solve(prob, Tsit5())\nplot(sol, ecosystem,\n    lw=2, title = \"Decoupled Ecosystem\",\n    xlabel = \"time\", ylabel = \"population size\"\n)","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicDynamics.jl/blob/master/examples/Lotka-Volterra.jl\"","category":"page"},{"location":"examples/Lotka-Volterra/#lotka_volterra","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"","category":"section"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"(Image: )","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"We will give three examples of deriving the Lotka-Volterra equations $ \\dot r(t) = \\alpha r(t) - \\beta r(t)f(t), \\dot f(t) = \\gamma f(t) r(t) - \\delta f(t)$ as a composition of primitive systems. First, we will show it as the composition of resource sharers where the undirected composition pattern is an undirected wiring diagram. Second, we will show it as the composition of machines where the directed composition pattern is a wiring diagram. Lastly, we will show it as the composition of machines where the directed composition pattern is an open circular port graph (open CPG).","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"Although these examples are quite small and you can easily work them out by hand,  this approach is based on the solid mathematical theory of operad algebras that allows you to scale to larger and more complex problems.","category":"page"},{"location":"examples/Lotka-Volterra/#Undirected-composition","page":"Lotka-Volterra Three Ways","title":"Undirected composition","text":"","category":"section"},{"location":"examples/Lotka-Volterra/#Undirected-wiring-diagrams","page":"Lotka-Volterra Three Ways","title":"Undirected wiring diagrams","text":"","category":"section"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"A standard Lotka-Volterra predator-prey model is the composition of three resource sharers:","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"a model of rabbit growth: this resource sharer has dynamics dot r(t) = alpha r(t) and one port which exposes the rabbit population.\na model of rabbit/fox predation: this resource sharer has dynamics dot r(t) = -beta r(t) f(t) dot f(t) = gamma r(t)f(t) and two ports which expose the rabbit and fox populations respectively\na model of fox population decline: this resource sharer has dynamics dot f(t) = -delta f(t) and one port which exposes the fox population.","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"However, there are not two independent rabbit populations â€“- one that grows and one that gets eaten by foxes. Likewise, there are not two independent fox populations â€“- one that declines and one that feasts on rabbits. To capture these interactions between the trio of resource sharers, we compose them by identifying the exposed rabbit populations and identifying the exposed fox populations.","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"using AlgebraicDynamics\nusing AlgebraicDynamics.UWDDynam\nusing Catlab.WiringDiagrams, Catlab.Programs\nusing LabelledArrays\nusing OrdinaryDiffEq, Plots, Plots.PlotMeasures\n\nconst UWD = UndirectedWiringDiagram\n\n# Define the primitive systems\ndotr(u,p,t) = p.Î±*u\ndotrf(u,p,t) = [-p.Î²*u[1]*u[2], p.Î³*u[1]*u[2]]\ndotf(u,p,t) = -p.Î´*u\n\nrabbit_growth = ContinuousResourceSharer{Float64}(1, dotr)\nrabbitfox_predation = ContinuousResourceSharer{Float64}(2, dotrf)\nfox_decline = ContinuousResourceSharer{Float64}(1, dotf)\n\n# Define the composition pattern\nrf = @relation (rabbits,foxes) begin\n    growth(rabbits)\n    predation(rabbits,foxes)\n    decline(foxes)\nend\n\n# Compose\nrabbitfox_system = oapply(rf, [rabbit_growth, rabbitfox_predation, fox_decline])\n\n# Solve and plot\nu0 = [10.0, 100.0]\nparams = LVector(Î±=.3, Î²=0.015, Î³=0.015, Î´=0.7)\ntspan = (0.0, 100.0)\n\nprob = ODEProblem(rabbitfox_system, u0, tspan, params)\nsol = solve(prob, Tsit5())\n\nplot(sol, rabbitfox_system,\n    lw=2, title = \"Lotka-Volterra Predator-Prey Model\",\n    xlabel = \"time\", ylabel = \"population size\"\n)","category":"page"},{"location":"examples/Lotka-Volterra/#Directed-composition","page":"Lotka-Volterra Three Ways","title":"Directed composition","text":"","category":"section"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"A standard Lotka-Volterra predator-prey model is the composition of two machines:","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"Evolution of a rabbit population: this machine has one input which represents a population of predators, h(t), that hunt rabbits. This machine has one output which emits the rabbit population r(t). The dynamics of this machine is the driven ODE dot r(t) = alpha r(t) - beta r(t) h(t)\nEvoluation of a fox population: this machine has one input which represents a population of prey, e(t), that are eaten by foxes. This machine has one output which emits the fox population f(t). The dynamics of this machine is the driven ODE dot f(t) =gamma f(t)e(t) - delta f(t)","category":"page"},{"location":"examples/Lotka-Volterra/#Wiring-diagrams","page":"Lotka-Volterra Three Ways","title":"Wiring diagrams","text":"","category":"section"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"Since foxes hunt rabbit, these machines compose by setting the fox population to be the input for rabbit evolution. Likewise, we set the rabbit population to be the input for fox evolution. We first implement this setting of inputs using a wiring diagram as our composition pattern.","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"using AlgebraicDynamics.DWDDynam\n\n# Define the primitive systems\ndotr(u, x, p, t) = [p.Î±*u[1] - p.Î²*u[1]*x[1]]\ndotf(u, x, p, t) = [p.Î³*u[1]*x[1] - p.Î´*u[1]]\n\nrabbit = ContinuousMachine{Float64}(1,1,1, dotr, (u, p, t) -> u)\nfox    = ContinuousMachine{Float64}(1,1,1, dotf, (u, p, t) -> u)\n\n# Define the composition pattern\nrabbitfox_pattern = WiringDiagram([], [:rabbits, :foxes])\nrabbit_box = add_box!(rabbitfox_pattern, Box(:rabbit, [:pop], [:pop]))\nfox_box = add_box!(rabbitfox_pattern, Box(:fox, [:pop], [:pop]))\n\nadd_wires!(rabbitfox_pattern, Pair[\n    (rabbit_box, 1) => (fox_box, 1),\n    (fox_box, 1)    => (rabbit_box, 1),\n    (rabbit_box, 1) => (output_id(rabbitfox_pattern), 1),\n    (fox_box, 1)    => (output_id(rabbitfox_pattern), 2)\n])\n\n# Compose\nrabbitfox_system = oapply(rabbitfox_pattern, [rabbit, fox])\n\n# Solve and plot\nu0 = [10.0, 100.0]\nparams = LVector(Î±=.3, Î²=0.015, Î³=0.015, Î´=0.7)\ntspan = (0.0, 100.0)\n\nprob = ODEProblem(rabbitfox_system, u0, tspan, params)\nsol = solve(prob, Tsit5())\n\nplot(sol, rabbitfox_system, params,\n    lw=2, title = \"Lotka-Volterra Predator-Prey Model\",\n    xlabel = \"time\", ylabel = \"population size\"\n)","category":"page"},{"location":"examples/Lotka-Volterra/#Open-CPG","page":"Lotka-Volterra Three Ways","title":"Open CPG","text":"","category":"section"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"We next implement the setting of inputs using an open CPG as our composition pattern. We will use a barbell CPG. A barbell has two boxes connected by n wires. In this instance we will set n to 1 since each machine receives and emits exactly one piece of information.","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"using AlgebraicDynamics.CPortGraphDynam\nusing AlgebraicDynamics.CPortGraphDynam: barbell\n\n# Define the composition pattern\nrabbitfox_pattern = barbell(1)\n\n# Compose\nrabbitfox_system = oapply(rabbitfox_pattern, [rabbit, fox])\n\n# Solve and plot\nu0 = [10.0, 100.0]\nparams = LVector(Î±=.3, Î²=0.015, Î³=0.015, Î´=0.7)\ntspan = (0.0, 100.0)\n\nprob = ODEProblem(rabbitfox_system, u0, tspan, params)\nsol = solve(prob, FRK65(0))\n\nplot(sol, lw=2, bottom_margin=10mm, left_margin=10mm, title = \"Lotka-Volterra Predator-Prey Model\", label=[\"rabbits\" \"foxes\"])\nxlabel!(\"Time\")\nylabel!(\"Population size\")","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicDynamics.jl/blob/master/examples/Ross-Macdonald.jl\"","category":"page"},{"location":"examples/Ross-Macdonald/#ross-macdonald","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"","category":"section"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"(Image: )","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"Authors: Sean L. Wu and Sophie Libkind","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"using AlgebraicDynamics.DWDDynam\nusing Catlab.WiringDiagrams\nusing LabelledArrays\n\nusing Catlab.Graphics\nusing DelayDiffEq, DifferentialEquations\nusing Plots","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"The Ross-Macdonald (RM) model is the canonical model of malaria transmission, first expressed by Sir Ronald Ross in 1911. The simplest form of the model is given by a system of 2 nonlinear ordinary differential equations describing Z, parasite prevalence in the mosquito vector population, and X, parasite prevalence in the vertebrate host population: $ \\dot X = mazbZ(1 - X) - rX, \\quad \\dot Z = acX (e^{-gn} - Z) - gZ  \\quad (1)$","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"The RM model is of supreme importance to modeling of malaria and other mosquito transmitted diseases because it is the simplest model that retains the fundamental processes involved in transmission: recovery of infected hosts, death of infected mosquitoes, and parasite transmission between discordant pairs of vectors and hosts. In this sense it represents the irreducible complexity to modeling mosquito borne diseases, such that any simpler model would be insufficient.","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"The model assumes that mosquitoes take bloodmeals (bites) on vertebrate hosts with rate a. Therefore, the per-capita rate at which susceptible mosquitoes become infected is acX, where c is the transmission efficiency from infectious humans to susceptible mosquitoes (probability of parasites successfully invading the mosquito given a bite occurs) and X is the probability the  bite lands on an infectious human. 1-Z is the proportion of mosquitoes who are susceptible but given an incubation period of n days during which mosquitoes suffer per-capita mortality at rate g, only a proportion e^-gn survive incubation to become infectious. Therefore the classic RM model will have statics that are consistent with the incorporation of an incubation period of fixed duration, but dynamics will not, as the delay is not incorporated into the equations.","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"Susceptible humans acquire infection at a rate mabZ, where m = MH, the ratio of mosquitoes to humans, a is as before, and b is the transmission efficiency from infectious mosquitoes to susceptible humans. Therefore mabZ gives the per-capita rate at which susceptible humans recieve parasites from the mosquito population. Infectious humans recover at a rate r (the rate at which the immune system clears parasites). Because m is considered a constant parameter, the model ignores seasonal fluctuations in mosquito (or host) population sizes. However, because the timescale of host dynamcis is typically slow in relation to mosquito dynamics, the approximation is often suitable over a transmission season.","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"The model's threshold criterion between the trivial equilibrium where both ZX are equal to zero (no disease) and the endemic equilibrium can be expressed by the basic reproductive number, giving the expected number of secondary infections arising from the introduction of a single infectious human, R_0 = fracma^2bce^-gnrg The endemic equilibrium is therefore: barX= fracR_0-1R_0 + fracacg quad barZ = fracacbarXg + acbarX e^-gn","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"From these equations, the nonlinear relationships that characterize observed malaria transmission can be understood. We implement them as follows:","category":"page"},{"location":"examples/Ross-Macdonald/#Diagram-of-Systems","page":"Ross-Macdonald Malaria Modeling","title":"Diagram of Systems","text":"","category":"section"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"First we must construct a diagram of systems which describes the interaction between the mosquito and host populations. The arrows between the two subsystems represents the bidirectional infection during bloodmeals.","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"rm = WiringDiagram([], [:mosquitos, :humans])\nmosq_box   = add_box!(rm, Box(:mosquitos, [:x], [:z]))\nhuman_box  = add_box!(rm, Box(:humans, [:z], [:x]))\noutput_box = output_id(rm)\n\nadd_wires!(rm, Pair[\n    (mosq_box, 1)  => (human_box, 1),\n    (human_box, 1) => (mosq_box, 1),\n    (mosq_box, 1)  => (output_box, 1),\n    (human_box, 1) => (output_box, 2)]\n)\n\n\nto_graphviz(rm)","category":"page"},{"location":"examples/Ross-Macdonald/#ODE-Model","page":"Ross-Macdonald Malaria Modeling","title":"ODE Model","text":"","category":"section"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"Next we implement the concrete mosquito and host dynamics given in Equation (1), and apply them to the diagram of systems. This composition is the complete Ross-Macdonald model which we can solve and plot.","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"dZdt = function(u,x,p,t)\n    Z = u[1]\n    X = x[1]\n    [p.a*p.c*X*(exp(-p.g*p.n) - Z) - p.g*Z]\nend\n\ndXdt = function(u,x,p,t)\n    X = u[1]\n    Z = x[1]\n    [p.m*p.a*p.b*Z*(1 - X) - p.r*X]\nend","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"mosquito_model = ContinuousMachine{Float64}(1, 1, 1, dZdt, (u,p,t) -> u)\nhuman_model    = ContinuousMachine{Float64}(1, 1, 1, dXdt, (u,p,t) ->  u)\n\nmalaria_model = oapply(rm,\n    Dict(:humans => human_model, :mosquitos => mosquito_model)\n)","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"params = LVector(a = 0.3, b = 0.55, c = 0.15,\n    g = 0.1, n = 10, r = 1.0/200, m = 0.5)\n\nu0 = [0.1, 0.3]\ntspan = (0.0, 365.0*2)\n\nprob = ODEProblem(malaria_model, u0, tspan, params)\nsol = solve(prob, Tsit5());\nnothing #hide","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"plot(sol, malaria_model,\n    lw=2, title = \"Ross-Macdonald Malaria model\",\n    xlabel = \"time\", ylabel = \"proportion infectious\",\n    color = [\"magenta\" \"blue\"]\n)\n\n# Plot the equilibrium behavior as well\na, b, c, g, n, r, m = params\nR0 = (m*a^2*b*c*exp(-g*n))/(r*g)\nXÌ„ = (R0 - 1)/(R0 + (a*c)/g)\nZÌ„ = (a*c*XÌ„)/(g + a*c*XÌ„)*exp(-g*n)\n\nN = length(sol)\nplot!(sol.t, fill(XÌ„, N), label = \"human equilibrium\", ls = :dash, lw = 2, color = \"blue\")\nplot!(sol.t, fill(ZÌ„, N), label = \"mosquito equilibrium\", ls = :dash, lw = 2, color = \"magenta\")","category":"page"},{"location":"examples/Ross-Macdonald/#ODE-Model-using-instantaneous-machines","page":"Ross-Macdonald Malaria Modeling","title":"ODE Model using instantaneous machines","text":"","category":"section"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"One way to decouple systems or isolate coupling points between different parts of a dynamical system is to use instantaneous machines, which allow processing of information to occur without (optionally) storing state themselves.","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"In this case we seperate the bloodmeal, where pathogen transmission occurs between the two species, into a seperate machine. This way, the dynamics of the human and mosquito machines do not need the other's state value, all the information has already been computed in the bloodmeal machine. For such a simple system, this arrangement may be superfluous, but in complex systems it can be beneficial to have seperate components which compute terms which are dependent on state variables \"external\" to a particular machine.","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"rmb = WiringDiagram([], [:mosquitos, :humans, :bloodmeal])\nmosquito_box = add_box!(rmb, Box(:mosquitos, [:Îº], [:Z]))\nhuman_box = add_box!(rmb, Box(:humans, [:EIR], [:X]))\nbloodmeal_box = add_box!(rmb, Box(:bloodmeal, [:X, :Z], [:Îº, :EIR]))\noutput_box = output_id(rmb)\n\nadd_wires!(rmb, Pair[\n    (bloodmeal_box, 1)  => (mosquito_box, 1),\n    (bloodmeal_box, 2) => (human_box, 1),\n    (human_box, 1)  => (bloodmeal_box, 1),\n    (mosquito_box, 1) => (bloodmeal_box, 2),\n    (mosquito_box, 1)  => (output_box, 1),\n    (human_box, 1) => (output_box, 2)]\n)","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"The wiring diagram is below. The bloodmeal machine computes the EIR (entomological inoculation rate) which is proportional to the force of infection upon susceptible humans, and the net infectiousness of humans to mosquitoes, commonly denoted kappa. The EIR is maZ where Z is the mosquito state variable, and kappa is cX where X is the human state variable.","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"These two terms are sent from the bloodmeal machine to the mosquito and human machines via their input ports. Then the dynamical system filling the mosquito machine is dotZ = a*kappa*(e^-gn - Z) - gZ and dotX = bEIR(1-X) - rX is the dynamical system filling the human machine.","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"to_graphviz(rmb)","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"bloodmeal = function(u,x,p,t)\n    X = x[1]\n    Z = x[2]\n    [p.c*X, p.m*p.a*Z]\nend\n\ndZdt = function(u,x,p,t)\n    Z = u[1]\n    Îº = x[1]\n    [p.a*Îº*(exp(-p.g*p.n) - Z) - p.g*Z]\nend\n\ndXdt = function(u,x,p,t)\n    X = u[1]\n    EIR = x[1]\n    [p.b*EIR*(1 - X) - p.r*X]\nend\n\nbloodmeal_model = InstantaneousContinuousMachine{Float64}(2, 0, 2, (u,x,p,t)->u, bloodmeal, [1=>1,2=>2])\nmosquito_model = ContinuousMachine{Float64}(1, 1, 1, dZdt, (u,p,t) -> u)\nhuman_model    = ContinuousMachine{Float64}(1, 1, 1, dXdt, (u,p,t) ->  u)\n\ninstantaneous_mosquito_model = InstantaneousContinuousMachine{Float64}(mosquito_model)\ninstantaneous_human_model = InstantaneousContinuousMachine{Float64}(human_model)\n\nmalaria_model = oapply(rmb,\n    Dict(:mosquitos => instantaneous_mosquito_model, :humans => instantaneous_human_model, :bloodmeal => bloodmeal_model)\n)","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"We use the same parameter values as previously given to solve the composed system, and plot the analytic equilibrium. Results are the same as for the previous system.","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"prob = ODEProblem(malaria_model, u0, tspan, params)\nsol = solve(prob, Tsit5());\nnothing #hide","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"plot(sol, label = [\"mosquitos\" \"humans\"],\n    lw=2, title = \"Ross-Macdonald Malaria model\",\n    xlabel = \"time\", ylabel = \"proportion infectious\",\n    color = [\"magenta\" \"blue\"]\n)\nN = length(sol)\nplot!(sol.t, fill(XÌ„, N), label = \"human equilibrium\", ls = :dash, lw = 2, color = \"blue\")\nplot!(sol.t, fill(ZÌ„, N), label = \"mosquito equilibrium\", ls = :dash, lw = 2, color = \"magenta\")","category":"page"},{"location":"examples/Ross-Macdonald/#Delay-Model","page":"Ross-Macdonald Malaria Modeling","title":"Delay Model","text":"","category":"section"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"The previous models did not capture the incubation period for the disease in the mosquito population. To do so we can replace the models with delay differential equations and apply them to the same diagram of systems representing the bloodmeal.","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"dzdt_delay = function(u,x,h,p,t)\n    Y, Z = u\n    Y_delay, Z_delay = h(p, t - p.n)\n    X, X_delay = x[1]\n\n    [p.a*p.c*X*(1 - Y - Z) -\n        p.a*p.c*X_delay*(1 - Y_delay - Z_delay)*exp(-p.g*p.n) -\n        p.g*Y,\n    p.a*p.c*X_delay*(1 - Y_delay - Z_delay)*exp(-p.g*p.n) -\n        p.g*Z]\nend\n\ndxdt_delay = function(u,x,h,p,t)\n    X, = u\n    Z, _ = x[1]\n    [p.m*p.a*p.b*Z*(1 - X) - p.r*X]\nend","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"mosquito_delay_model = DelayMachine{Float64, 2}(\n    1, 2, 1, dzdt_delay, (u,h,p,t) -> [[u[2], h(p,t - p.n)[2]]])\n\nhuman_delay_model = DelayMachine{Float64, 2}(\n    1, 1, 1, dxdt_delay, (u,h,p,t) -> [[u[1], h(p, t - p.n)[1]]])\n\nmalaria_delay_model = oapply(rm,\n    Dict(:humans => human_delay_model, :mosquitos => mosquito_delay_model)\n)","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"params = LVector(a = 0.3, b = 0.55, c = 0.15,\n    g = 0.1, n = 10, r = 1.0/200, m = 0.5)\n\nu0_delay = [0.09, .01, 0.3]\ntspan = (0.0, 365.0*3)\nhist(p,t) = u0_delay;\n\nprob = DDEProblem(malaria_delay_model, u0_delay, [], hist, tspan, params)\nalg = MethodOfSteps(Tsit5())\nsol = solve(prob, alg)\n\nplot(sol, label=[\"non-infectious mosquito population\" \"infectious mosquito population\" \"host population\"],\n    lw=2, title = \"Ross-Macdonald malaria model\",\n    xlabel = \"time\", ylabel = \"proportion infectious\",\n    color = [\"magenta\" \"red\" \"blue\"]\n)","category":"page"},{"location":"examples/Ross-Macdonald/","page":"Ross-Macdonald Malaria Modeling","title":"Ross-Macdonald Malaria Modeling","text":"While the equilibrium points of the two models are identical, they exhibit different dynamical behavior before settling down to equilibrium. Because models are often used to examine how the system may respond to intervention, incorporating additional biological realism can produce more plausible results regarding the expected time for interventions to affect the system. In any case, such simple models are best used as tools to explain basic concepts in malaria epidemiology rather than descriptions of real systems, which are likely far from equilibrium and affected by weather, climate, policy, and other external forces.","category":"page"},{"location":"#AlgebraicDynamics.jl","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"","category":"section"},{"location":"","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"AlgebraicDynamics.jl is a library for compositional dynamical systems. We build on Catlab.jl to provide a software interface for specifying and solving dynamical systems with compositional and hierarchical structure. The implementation of the composition of dynamical systems follows the mathematics of operads and operad algebras.","category":"page"},{"location":"#Composing-Dynamical-Systems","page":"AlgebraicDynamics.jl","title":"Composing Dynamical Systems","text":"","category":"section"},{"location":"","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"The general process for composing  dynamical systems is as follows:","category":"page"},{"location":"","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"Pick a composition syntax. A composition syntax may be either undirected or directed. In this library, composition is implemented for the following syntaxes:\nundirected wiring diagrams (an undirected composition syntax)\nwiring diagrams (a directed composition syntax)\nopen circular port graphs, also called open CPGs (a directed composition syntax)\nDefine a composition pattern. Implement a specific undirected wiring diagram, wiring diagram, or open CPG that defines how the primitive systems will be composed. The number of boxes in the composition pattern is the number of primitive systems that will be composed.\nDefine the primitive systems to compose.\nFor an undirected composition pattern, the primitive systems are implemented by resource sharers. A resource sharer has four components:\nports\nstates\na dynamics function, f\na port map,  m\nThe dynamics function can be either continuous time dot u(t) = f(u(t) p t) or discrete time u_n +1 = f(u_n p t). In both cases, u contains the state and p contains the parameters. Also in both cases, the port map assigns a state to each port. We say the port exposes the state it is assigned. For continuous time use ContinuousResourceSharer{T} and for discrete time use DiscreteResourceSharer{T}. The type T represents the values that the states can take on.\nFor a directed composition pattern, the primitive systems are implemented by machines. A machine has five components:\ninputs (also called exogenous variables)\nstates\noutputs\na dynamics function,  f\na readout function,  r\nThe dynamics function can be either continuous time dot u(t) = f(u(t) x(t) p t) or discrete time u_n+1 = f(u_n x_n p t). In both cases, u contains the state, x contains the exogenous variables, and p contains the parameters. Also in both cases, the readout function r(u(t)) is a function of the state. For continuous time use ContinuousMachine{T} and for discrete time use DiscreteMachine{T}. The type T represents the values that the inputs, states, and outputs can take on.\nCompose. The oapply method takes a composition pattern and  primitive systems, and it returns the composite system. Each oapply method implements an operad algebra which specifies a regime for composing dynamical systems. See [Schultz et al. 2019] and [Vagner et al. 2015] for definitions of the operad algebras mathsfCDS and mathsfDDS for directed composition. See [Baez and Pollard 2017] for definitions of the operad algebra mathsfDynam for undirected composition. See [Libkind 2020] for a general overview of these operad algebras.","category":"page"},{"location":"#Solving-Dynamical-Systems","page":"AlgebraicDynamics.jl","title":"Solving Dynamical Systems","text":"","category":"section"},{"location":"","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"Once you have built the composite system, you can solve it and plot the solution.","category":"page"},{"location":"","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"For continuous machines and resource sharers, you can construct an ODEProblem or a DDEProblem. When the composition pattern is a wiring diagram, we recommend solvers Tsit5() with dtmax specified and FRK65(w=0).\nFor discrete machines and resource sharers, you can construct a DiscreteProblem or explicitly compute a trajectory.","category":"page"},{"location":"","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"In either case, be sure to import OrdinaryDiffEq.jl.","category":"page"},{"location":"#Future-Work","page":"AlgebraicDynamics.jl","title":"Future Work","text":"","category":"section"},{"location":"","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"Add more integrators beyond the simple Euler's method\nInclude higher order polynomial methods and symplectic and implicit methods for physical problems\nIntegrate with AlgebraicPetri.jl","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicDynamics.jl/blob/master/examples/CPG_examples.jl\"","category":"page"},{"location":"examples/CPG_examples/#cpg_examples","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"","category":"section"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"(Image: )","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"using AlgebraicDynamics.DWDDynam\nusing AlgebraicDynamics.CPortGraphDynam\nusing AlgebraicDynamics.CPortGraphDynam: draw, barbell, gridpath, grid, meshpath\n\nusing Catlab\nusing Catlab.WiringDiagrams\nusing Catlab.WiringDiagrams.CPortGraphs\nusing Catlab.Theories\nusing Catlab.CategoricalAlgebra\n\nusing OrdinaryDiffEq\nusing Plots, Plots.PlotMeasures\n\nusing PrettyTables","category":"page"},{"location":"examples/CPG_examples/#SIR-Epidemiology-Model","page":"Open Circular Port Graph Examples","title":"SIR Epidemiology Model","text":"","category":"section"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"An SIR epidemiology model has three types of people: susceptible, infected, and recovered. When a susceptible person interacts with infected person, the susceptible person also becomes infected. Over time infected people  recover. Transition rates determine the how frequently susceptible people come into contact with infected people and how fast infected people recover. The system evolves according to the law of mass action.","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"In a multi-city SIR model, each city has susceptible, infected, and recovered populations. To see the spread of the disease we will consider both susceptible and infected people moving between cities. To define a multi-city SIR model, we can compose multiple single-city SIR models using the composition syntax of open CPGs. The composition pattern will consist of three boxes each of which will be filled by a single-city SIR model. Ports expose the susceptible and infected populations of each city. One set of wires connect the susceptible and infected populations of cities 1 and 2. A second set of wires connect the susceptible and infected popuation of cities 2 and 3.","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"# Define the composition pattern\ndâ‚€ = OpenCPortGraph()\nadd_parts!(dâ‚€, :Box, 1)\ndâ‚ = barbell(2)\nF = ACSetTransformation((Box=[2],), dâ‚€, dâ‚)\nG = ACSetTransformation((Box=[1],), dâ‚€, dâ‚)\ndâ‚‚ = apex(pushout(F,G))\n\n# Define the primitive systems\nÎ², Î¼, Î±â‚, Î±â‚‚ = 0.4, 0.4, 0.01, 0.01\n\nsirfuncb = (u,x,p,t)->[-Î²*u[1]*u[2] - Î±â‚*(u[1]-x[1]), # SÌ‡\n                        Î²*u[1]*u[2] - Î¼*u[2] - Î±â‚‚*(u[2]-x[2]), #IÌ‡\n                        Î¼*u[2] # RÌ‡\n                        ]\nsirfuncm = (u,x,p,t)->[-Î²*u[1]*u[2] - Î±â‚*(u[1]-(x[1]+x[3])/2),\n                        Î²*u[1]*u[2] - Î¼*u[2] - Î±â‚‚*(u[2]-(x[2]+x[4])/2),\n                        Î¼*u[2]\n                       ]\n\nboundary  = ContinuousMachine{Float64}(2,3,sirfuncb, (u,p,t)->u[1:2])\nmiddle    = ContinuousMachine{Float64}(4,3, sirfuncm, (u,p,t)->u[[1,2,1,2]])\n\n# Compose\nthreecity = oapply(dâ‚‚, [boundary,middle,boundary])","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"First, we will approximate the solution to the three city SIR model using Euler's method. The initial condition has 100 susceptible people in each city a single infected person in the first city. We show the infected populations in each city over time.","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"u0 = [100,1,0,100,0,0,100,0,0.0]\n\nh = 0.01\ntspan = (0.0, 1.0)\nthreecity_approx = euler_approx(threecity, h)\nprob = DiscreteProblem(threecity_approx, u0, [], tspan, nothing)\nsol = solve(prob, FunctionMap(); dt = h)\n\nmap(sol) do u\n    return (i1=u[2], i2=u[5], i3=u[8])\nend |> pretty_table","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"Next, we will solve the continuous system and plot the results. Over time the infected populations increase and the susceptible populations decrease. The delays in the plots illustrate how the disease spreads from city 1 to city 2 and then from city 2 to city 3.","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"# Solve and plot\nprob = ODEProblem(threecity, u0, tspan)\nsol = solve(prob, Tsit5(); dtmax = 0.01)\n\nplot(sol, lw=2, title = \"SIR Epidemiology Model\", bottom_margin=10mm, left_margin=10mm,\n    label=[\"S\" \"I\" \"R\"])","category":"page"},{"location":"examples/CPG_examples/#Cellular-automata","page":"Open Circular Port Graph Examples","title":"Cellular automata","text":"","category":"section"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"Circular port graphs are particularly useful for modeling systems where the composition pattern is given by a grid and where the dynamics are repetative. In the case of cellular automata the composition pattern is a row of n cells each of which is connected to its two neighbors. The primitive systems are identical machines whose discrete dynamics are a specified rule. See here for a complete set of rules and the patterns they generate.","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"function Rule(k::Int)\n    (left_neighbor, x, right_neighbor) ->\n    Bool(digits(k, base=2, pad=8)[1 + right_neighbor + 2*x + 4*left_neighbor])\nend\n\n# Define the composition pattern\nn = 100\nrow = apex(gridpath(n, 1))\n\n# Define the primitive system which will be repeated for each cell\nrule = DiscreteMachine{Bool}(2, 1, 2,\n            (u, x, p, t)->Rule(p)(x[2], u[1], x[1]),\n            (u,p,t)->[u[1], u[1]])\n\n# Compose\nautomaton = oapply(row, rule)\n\n# Solve and plot\nu0 = zeros(Int, n); u0[Int(n/2)] = 1\n\nrule_number = 126\ntspan = (0.0, 100.0)\nprob = DiscreteProblem(automaton, u0, [0,0], tspan, rule_number)\nsol = solve(prob, FunctionMap())\nspy(transpose(reduce(hcat, sol.u)))","category":"page"}]
}
