var documenterSearchIndex = {"docs":
[{"location":"api/#Library-Reference","page":"Library Reference","title":"Library Reference","text":"","category":"section"},{"location":"api/#Resource-Sharers-and-Machines","page":"Library Reference","title":"Resource Sharers and Machines","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"AlgebraicDynamics.UWDDynam.AbstractResourceSharer\nAlgebraicDynamics.UWDDynam.ContinuousResourceSharer\nAlgebraicDynamics.UWDDynam.DiscreteResourceSharer\nAlgebraicDynamics.DWDDynam.AbstractMachine\nAlgebraicDynamics.DWDDynam.ContinuousMachine\nAlgebraicDynamics.DWDDynam.DiscreteMachine\nAlgebraicDynamics.UWDDynam.eval_dynamics\nAlgebraicDynamics.UWDDynam.euler_approx","category":"page"},{"location":"api/#AlgebraicDynamics.UWDDynam.AbstractResourceSharer","page":"Library Reference","title":"AlgebraicDynamics.UWDDynam.AbstractResourceSharer","text":"An undirected open dynamical system operating on information of type T.\n\nA resource sharer r has signature r.nports.\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicDynamics.UWDDynam.ContinuousResourceSharer","page":"Library Reference","title":"AlgebraicDynamics.UWDDynam.ContinuousResourceSharer","text":"An undirected open continuous system. The dynamics function f defines an ODE dot u(t) = f(u(t)pt).\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicDynamics.UWDDynam.DiscreteResourceSharer","page":"Library Reference","title":"AlgebraicDynamics.UWDDynam.DiscreteResourceSharer","text":"An undirected open discrete system. The dynamics function f defines a discrete update rule u_n+1 = f(u_n p t).\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicDynamics.DWDDynam.AbstractMachine","page":"Library Reference","title":"AlgebraicDynamics.DWDDynam.AbstractMachine","text":"A directed open dynamical system operating on information fo type T. A machine  m has type signature  (m.ninputs, m.outputs).\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicDynamics.DWDDynam.ContinuousMachine","page":"Library Reference","title":"AlgebraicDynamics.DWDDynam.ContinuousMachine","text":"An undirected open continuous system. The dynamics function f defines an ODE dot u(t) = f(u(t)x(t)pt) where u is the state and x captures the exogenous variables.\n\nThe readout function may only depend on the state, so it must be of the form r(u(t)).\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicDynamics.DWDDynam.DiscreteMachine","page":"Library Reference","title":"AlgebraicDynamics.DWDDynam.DiscreteMachine","text":"A directed open discrete dynamical system. The dynamics function f defines a discrete update rule u_n+1 = f(u_n x_n p t) where u_n is the state and x_n is the value of the exogenous variables at the nth time step.\n\nThe readout function may only depend on the state, so it must be of the form r(u_n).\n\n\n\n\n\n","category":"type"},{"location":"api/#AlgebraicDynamics.UWDDynam.eval_dynamics","page":"Library Reference","title":"AlgebraicDynamics.UWDDynam.eval_dynamics","text":"eval_dynamics(m::AbstractMachine, u::AbstractVector, xs::AbstractVector, p, t)\n\nEvaluates the dynamics of the machine m at state u, parameters p, and time t. The exogenous variables are set by xs which may either be a collection of functions x(t) or a collection of constant values. \n\nThe length of xs must equal the number of inputs to m.\n\n\n\n\n\neval_dynamics(r::AbstractResourceSharer, u::AbstractVector, p, t)\n\nEvaluates the dynamics of the resource sharer r at state u, parameters p, and time t.\n\nOmitting t and p is allowed if the dynamics of r does not depend on them.\n\n\n\n\n\n","category":"function"},{"location":"api/#AlgebraicDynamics.UWDDynam.euler_approx","page":"Library Reference","title":"AlgebraicDynamics.UWDDynam.euler_approx","text":"euler_approx(m::ContinuousMachine, h)\n\nTransforms a continuous machine m into a discrete machine via Euler's method with step size h. If the dynamics of m is given by dotu(t) = f(u(t)x(t)pt) the the dynamics of the new discrete system is given by the update rule u_n+1 = u_n + h f(u_n x_n p t).\n\n\n\n\n\neuler_approx(m::ContinuousMachine)\n\nTransforms a continuous machine m into a discrete machine via Euler's method where the step size is introduced as a new parameter, the last in the list of parameters.\n\n\n\n\n\neuler_approx(r::ContinuousResourceSharer, h)\n\nTransforms a continuous resource sharer r into a discrete resource sharer via Euler's method with step size h. If the dynamics of r is given by dotu(t) = f(u(t)pt) the the dynamics of the new discrete system is given by the update rule u_n+1 = u_n + h f(u_n p t).\n\n\n\n\n\neuler_approx(r::ContinuousResourceSharer)\n\nTransforms a continuous resource sharer r into a discrete resource sharer via Euler's method where the step size is introduced as a new parameter, the last in the list of parameters.\n\n\n\n\n\n","category":"function"},{"location":"api/#oapply","page":"Library Reference","title":"oapply","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"AlgebraicDynamics.UWDDynam.fills\noapply","category":"page"},{"location":"api/#AlgebraicDynamics.UWDDynam.fills","page":"Library Reference","title":"AlgebraicDynamics.UWDDynam.fills","text":"fills(r::AbstractResourceSharer, d::AbstractUWD, b::Int)\n\nChecks if r is of the correct signature to fill box b of the undirected wiring diagram d.\n\n\n\n\n\n","category":"function"},{"location":"api/#Catlab.WiringDiagrams.WiringDiagramAlgebras.oapply","page":"Library Reference","title":"Catlab.WiringDiagrams.WiringDiagramAlgebras.oapply","text":"oapply(d::OpenCPortGraph, ms::Vector)\n\nImplements the operad algebras for directed composition of dynamical systems given a  composition pattern (implemented by an open circular port graph d) and primitive systems (implemented by a collection of  machines ms).\n\nEach box of the composition pattern d is filled by a machine with the  appropriate type signature. Returns the composite machine.\n\n\n\n\n\noapply(d::OpenCPortGraph, m::AbstractMachine)\n\nA version of oapply where each box of d is filled with the machine m.\n\n\n\n\n\noapply(d::WiringDiagram, ms::Vector)\n\nImplements the operad algebras for directed composition of dynamical systems given a  composition pattern (implemented by a directed wiring diagram d) and primitive systems (implemented by a collection of  machines ms).\n\nEach box of the composition pattern d is filled by a machine with the  appropriate type signature. Returns the composite machine.\n\n\n\n\n\noapply(d::WiringDiagram, m::AbstractMachine)\n\nA version of oapply where each box of d is filled with the machine m.\n\n\n\n\n\noapply(d::WiringDiagram, generators::Dict)\n\nA version of oapply where generators is a dictionary mapping the name of each box to its corresponding machine. \n\n\n\n\n\n oapply(d::AbstractUWD, rs::Vector)\n\nImplements the operad algebras for undirected composition of dynamical systems given a composition pattern (implemented by an undirected wiring diagram d) and primitive systems (implemented by a collection of resource sharers rs). Returns the composite resource sharer.\n\nEach box of d must be filled by a resource sharer of the appropriate type signature. \n\n\n\n\n\noapply(d::AbstractUWD, r::AbstractResourceSharer)\n\nA version of oapply where each box of d is filled with the resource sharer r.\n\n\n\n\n\n oapply(d::AbstractUWD, generators::Dict)\n\nA version of oapply where generators is a dictionary mapping the name of each box to its corresponding resource sharer.\n\n\n\n\n\n","category":"function"},{"location":"api/#Integration-with-OrdinaryDiffEq.jl-and-DynamicalSystems.jl","page":"Library Reference","title":"Integration with OrdinaryDiffEq.jl and DynamicalSystems.jl","text":"","category":"section"},{"location":"api/","page":"Library Reference","title":"Library Reference","text":"ODEProblem\nDiscreteDynamicalSystem\ntrajectory","category":"page"},{"location":"api/#SciMLBase.ODEProblem","page":"Library Reference","title":"SciMLBase.ODEProblem","text":"ODEProblem(m::ContinuousMachine, xs::Vector, u0::Vector, tspan)\n\nConstructs an ODEProblem from the vector field defined by (u,p,t) -> m.dynamics(u, x, p, t). The exogenous variables are determined by xs.\n\n\n\n\n\nODEProblem(r::ContinuousResourceSharer, u0::Vector, tspan)\n\nConstructs an ODEProblem from the vector field defined by r.dynamics(u,p,t).\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicalSystemsBase.DiscreteDynamicalSystem","page":"Library Reference","title":"DynamicalSystemsBase.DiscreteDynamicalSystem","text":"DiscreteDynamicalSystem(m::DiscreteMachine, xs::Vector, u0::Vector, p)\n\nConstructs an DiscreteDynamicalSystem from the equation of motion defined by  (u,p,t) -> m.dynamics(u, x, p, t). The exogenous variables are determined by xs. Pass nothing in place of p if your system does not have parameters.\n\n\n\n\n\nDiscreteDynamicalSystem(r::DiscreteResourceSharer, u0::Vector, p)\n\nConstructs a DiscreteDynamicalSystem from the equation of motion r.dynamics(u,p,t).  Pass nothing in place of p if your system does not have parameters.\n\n\n\n\n\n","category":"type"},{"location":"api/#DynamicalSystemsBase.trajectory","page":"Library Reference","title":"DynamicalSystemsBase.trajectory","text":"trajectory(r::DiscreteResourceSharer, u0::AbstractVector, p, nsteps::Int; dt::Int = 1)\n\nEvolves the resouce sharer r for nsteps times with step size dt, initial condition u0, and parameters p.\n\n\n\n\n\ntrajectory(m::DiscreteMachine, u0::AbstractVector, xs::AbstractVector, p, nsteps::Int; dt::Int = 1)\n\nEvolves the machine m for nsteps times with step size dt, initial condition u0, and parameters p. Any inputs to m are determied by xs. If m has no inputs then you can omit xs.\n\n\n\n\n\n","category":"function"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicDynamics.jl/blob/master/examples/Ecosystem.jl\"","category":"page"},{"location":"examples/Ecosystem/#ecosystem_example","page":"Ecosystem Models","title":"Ecosystem Models","text":"","category":"section"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"(Image: )","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"using AlgebraicDynamics\nusing AlgebraicDynamics.DWDDynam\nusing AlgebraicDynamics.UWDDynam\n\nusing Catlab.CategoricalAlgebra\nusing Catlab.WiringDiagrams\nusing Catlab.Graphics\nusing Catlab.Programs\n\nusing OrdinaryDiffEq\nusing Plots, Plots.PlotMeasures","category":"page"},{"location":"examples/Ecosystem/#Land-Ecosystem","page":"Ecosystem Models","title":"Land Ecosystem","text":"","category":"section"},{"location":"examples/Ecosystem/#Rabbits-and-foxes","page":"Ecosystem Models","title":"Rabbits and foxes","text":"","category":"section"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"A standard Lotka Volterra predator-prey model is the composition of three primitive resource sharers:","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"a model of rabbit growth: this resource sharer has dynamics dot r(t) = alpha r(t) and one port which exposes the rabbit population.\na model of rabbit/fox predation: this resource sharer has dynamics dot r(t) = -beta r(t) f(t) dot f(t) = gamma r(t)f(t) and two ports which expose the rabbit and fox populations respectively.\na model of fox population decline: this resource sharer has dynamics dot f(t) = -delta f(t) and one port which exposes the fox population.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"However, there are not two independent rabbit populations – one that grows and one that gets eaten by foxes. Likewise, there are not two independent fox populations – one that declines and one that feasts on rabbits. To capture these interactions between the trio of resource sharers, we compose them by identifying the exposed rabbit populations and identifying the exposed fox populations. The syntax for this undirected composition is defined by an undirected wiring diagram.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Define the primitive systems\ndotr(u,p,t) = p[1]*u\ndotrf(u,p,t) = [-p[2]*u[1]*u[2], p[3]*u[1]*u[2]]\ndotf(u,p,t) = -p[4]*u\n\nrabbit_growth = ContinuousResourceSharer{Float64}(1, dotr)\nrabbitfox_predation = ContinuousResourceSharer{Float64}(2, dotrf)\nfox_decline = ContinuousResourceSharer{Float64}(1, dotf)\n\n# Define the composition pattern\nrabbitfox_pattern = @relation (rabbits, foxes) begin\n    rabbit_growth(rabbits)\n    rabbitfox_predation(rabbits,foxes)\n    fox_decline(foxes)\nend\n\n# Compose\nrabbitfox_system = oapply(rabbitfox_pattern, [rabbit_growth, rabbitfox_predation, fox_decline])","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"Previously, when we derived the Lotka-Volterra model via undirected composition, we by-hand defined the undirected wiring diagram that implements the composition pattern. In contrast, here we implement the same composition pattern as before but this time using the @relation macro. This strategy simplifies the definition and explicitly names the boxes and variables. We  visualize the composition pattern below.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"to_graphviz(rabbitfox_pattern, box_labels = :name, junction_labels = :variable, edge_attrs=Dict(:len => \".75\"))","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"We can now construct an ODEProblem from the resource sharer rabbitfox_system and plot the solution.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"α, β, γ, δ = 0.3, 0.015, 0.015, 0.7\nparams = [α, β, γ, δ]\n\nu0 = [10.0, 100.0]\ntspan = (0.0, 100.0)\n\nprob = ODEProblem(rabbitfox_system, u0, tspan, params)\nsol = solve(prob, Tsit5())\n\nplot(sol, lw=2, title = \"Lotka-Volterra Predator-Prey Model\", bottom_margin=10mm, left_margin=10mm, label=[\"rabbits\" \"foxes\"])\nxlabel!(\"Time\")\nylabel!(\"Population size\")","category":"page"},{"location":"examples/Ecosystem/#Rabbits,-foxes,-and-hawks","page":"Ecosystem Models","title":"Rabbits, foxes, and hawks","text":"","category":"section"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"Suppose we now have a three species ecosystem containing rabbits, foxes, and hawks. Foxes and hawks both prey upon rabbits but do not interact with each other. This ecosystem consists of five primitive systems which share variables.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"rabbit growth:  dot r(t) = alpha r(t)\nrabbit/fox predation:  dot r(t) = -beta r(t) f(t) dot f(t) = delta r(t)f(t)\nfox decline:  dot f(t) = -gamma f(t)\nrabbit/hawk predation: dot r(t) = -beta r(t)h(t) dot h(t) = delta r(t)h(t)\nhawk decline:  dot h(t) = -gamma h(t)","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"This means the desired composition pattern has five boxes and many ports and wires to keep track of. Instead of implementing this composition pattern by hand, we construct it as a pushout.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Define the composition pattern for rabbit growth\nrabbit_pattern = @relation (rabbits,) -> rabbit_growth(rabbits)\n\n# Define the composition pattern for the rabbit/hawk Lotka Volterra model\nrabbithawk_pattern = @relation (rabbits, hawks) begin\n    rabbit_growth(rabbits)\n    rabbit_hawk_predation(rabbits,hawks)\n    hawk_decline(hawks)\nend\n\n# Define transformations between the composition patterns\nrabbitfox_transform  = ACSetTransformation((Box=[1], Junction=[1], Port=[1], OuterPort=[1]), rabbit_pattern, rabbitfox_pattern)\nrabbithawk_transform = ACSetTransformation((Box=[1], Junction=[1], Port=[1], OuterPort=[1]), rabbit_pattern, rabbithawk_pattern)\n\n# Take the pushout to define the composition pattern for the rabbit, fox, hawk system\nrabbitfoxhawk_pattern = ob(pushout(rabbitfox_transform, rabbithawk_transform))\n\n# Visualize the compsition pattern\nto_graphviz(rabbitfoxhawk_pattern, box_labels = :name, junction_labels = :variable, edge_attrs=Dict(:len => \".9\"))","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Define the additional primitive systems\ndotrh(x, p, t) = [-p[5]*x[1]*x[2], p[6]*x[1]*x[2]]\ndoth(x, p, t)  = -p[7]*x\n\nrabbithawk_predation = ContinuousResourceSharer{Float64}(2, dotrh)\nhawk_decline         = ContinuousResourceSharer{Float64}(1, doth)\n\n# Compose\nland_system = oapply(rabbitfoxhawk_pattern,\n                        [rabbit_growth, rabbitfox_predation, fox_decline,\n                         rabbithawk_predation, hawk_decline])\n\n# Solve and plot\nβ′, γ′, δ′ = .01, .01, .5\nparams = vcat(params, [β′, γ′, δ′])\n\nu0 = [10.0, 100.0, 50.0]\ntspan = (0.0, 100.0)\n\nprob = ODEProblem(land_system, u0, tspan, params)\nsol = solve(prob, Tsit5())\n\nplot(sol, lw=2, title = \"Land Ecosystem\", bottom_margin=10mm, left_margin=10mm, label=[\"rabbits\" \"foxes\" \"hawks\"])\nxlabel!(\"Time\")\nylabel!(\"Population size\")","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"Unfortunately, the hawks are going extinct in this model. We'll have to give hawks something else to eat!","category":"page"},{"location":"examples/Ecosystem/#Ocean-Ecosystem","page":"Ecosystem Models","title":"Ocean Ecosystem","text":"","category":"section"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"Consider a ocean ecosystem containing three species —- little fish, big fish, and sharks -— with two predation interactions —- sharks eat big fish and big fish eat little fish.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"This ecosystem can be modeled as the composition of 3 machines:","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"Evolution of the little fish population:  this machine has one exogenous variable which represents a population of predators h(t) that hunt little fish. This machine has one output which emits the little fish population. The dynamics of this machine is the driven ODE dot f(t) = alpha f(t) - beta f(t)h(t)\nEvolution of the big fish population:  this machine has two exogenous variables which represent a population of prey e(t) that are eaten by big fish and a population of predators h(t) which hunt big fish. This machine has one output which emits the big fish population. The dynamics of this machine is the drive ODE dot F(t) = gamma F(t)e(t) - delta F(t) - betaF(t)h(t)\nEvolution of the shark population:  this machine has one exogenous variable which represents a population of prey e(t) that are eaten by sharks. This machine has one output which emits the shark population. The dynamics of this machine is the driven ODE dot s(t) = gammas(t)e(t) - deltas(t)","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Define the primitive systems\ndotfish(f, x, p, t) = [p[1]*f[1] - p[2]*x[1]*f[1]]\ndotFISH(F, x, p, t) = [p[3]*x[1]*F[1] - p[4]*F[1] - p[5]*x[2]*F[1]]\ndotsharks(s, x, p, t) = [p[6]*s[1]*x[1]-p[7]*s[1]]\n\nfish   = ContinuousMachine{Float64}(1,1,1, dotfish,   f->f)\nFISH   = ContinuousMachine{Float64}(2,1,1, dotFISH,   F->F)\nsharks = ContinuousMachine{Float64}(1,1,1, dotsharks, s->s)","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"We compose these machines by (1) sending the output of the big fish machine as the input to both the little fish and shark machines and (2) sending the output of the little fish and shark machines as the inputs to the big fish machine. The syntax for this directed composition is given by a directed wiring diagram.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Define the composition pattern\nocean_pattern = WiringDiagram([], [])\nfish_box = add_box!(ocean_pattern, Box(:fish, [:pop], [:pop]))\nFish_box = add_box!(ocean_pattern, Box(:Fish, [:pop, :pop], [:pop]))\nshark_box = add_box!(ocean_pattern, Box(:shark, [:pop], [:pop]))\n\nadd_wires!(ocean_pattern, Pair[\n    (fish_box, 1)  => (Fish_box, 1),\n    (shark_box, 1) => (Fish_box, 2),\n    (Fish_box, 1)  => (fish_box, 1),\n    (Fish_box, 1)  => (shark_box, 1)\n])\n\n# Visualize the composition pattern\nto_graphviz(ocean_pattern, orientation=TopToBottom)","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Compose\nocean_system = oapply(ocean_pattern, [fish, FISH, sharks])\n\n# Solve and plot\nα, β, γ, δ, β′, γ′, δ′ = 0.35, 0.015, 0.015, 0.7, 0.017, 0.017, 0.35\nparams = [α, β, γ, δ, β′, γ′, δ′]\n\nu0 = [100.0, 10, 2.0]\ntspan = (0.0, 100.0)\n\nprob = ODEProblem(ocean_system, u0, tspan, params)\nsol = solve(prob, FRK65(0))\n\nplot(sol, lw=2, title = \"Ocean Ecosystem\", bottom_margin=10mm, left_margin=10mm, label=[\"little fish\" \"big fish\" \"sharks\"])\nxlabel!(\"Time\")\nylabel!(\"Population size\")","category":"page"},{"location":"examples/Ecosystem/#Total-ecosystem","page":"Ecosystem Models","title":"Total ecosystem","text":"","category":"section"},{"location":"examples/Ecosystem/#Another-layer-of-composition","page":"Ecosystem Models","title":"Another layer of composition","text":"","category":"section"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"We will introduce a final predation interaction – hawks eat little fish –  which will combine the land and ocean ecosystems.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"There will be 16 parameters in to the total ecosystem.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"parameters 1-7 will determine the land ecosystem\nparameters 8 and 9 will determine the hawk/little fish predation. Parameter 8 gives the rate of hawk growth and parameter 8 gives the rate of little fish decline.\nparameter 10-16 will determine the ocean ecosystem.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"The composition will be as resource shareres so the first thing we will do is use the dynamics of the machine ocean_system to define the dynamics of a resource sharer. We will also define a resource sharer that models hawk/little fish predation.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Define the additional primitive systems\nocean_system_rs = ContinuousResourceSharer{Float64}(3, (u,p,t)->eval_dynamics(ocean_system, u, [], p[10:16]))\n\ndothf(u,p,t) = [p[8]*u[1]*u[2], -p[9]*u[1]*u[2]]\nfishhawk_predation = ContinuousResourceSharer{Float64}(2, dothf)\n\n# Define the composition pattern\neco_pattern = @relation () where (rabbits, foxes, hawks, littlefish, BigFish, sharks)  begin\n    turf(rabbits,foxes,hawks)\n    air(hawks, littlefish)\n    surf(littlefish, BigFish, sharks)\nend\n\n# Visualize the composition pattern\nto_graphviz(eco_pattern, box_labels = :name, junction_labels = :variable, edge_attrs=Dict(:len => \".75\"))","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Compose\necosystem=oapply(eco_pattern, [land_system, fishhawk_predation, ocean_system_rs])","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"We can now plot the evolution of the total ecosystem.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"# Solve and plot\nu0 = [100.0, 50.0, 20.0, 100, 10, 2.0]\ntspan = (0.0, 100.0)\n\nparams = [0.3, 0.015, 0.015, 0.7, .01, .01, .5,\n          0.001, 0.003,\n          0.35, 0.015, 0.015, 0.7, 0.017, 0.017, 0.35]\n\nprob = ODEProblem(ecosystem, u0, tspan, params)\nsol = solve(prob, Tsit5())\nplot(sol, lw=2, bottom_margin=10mm, left_margin=10mm, label = [\"rabbits\" \"foxes\" \"hawks\" \"little fish\" \"big fish\" \"sharks\"])","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"Let's zoom in on a narrower time-window.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"tspan = (0.0, 30.0)\n\nprob = ODEProblem(ecosystem, u0, tspan, params)\nsol = solve(prob, Tsit5())\nplot(sol, lw=2, bottom_margin=10mm, left_margin=10mm, label = [\"rabbits\" \"foxes\" \"hawks\" \"little fish\" \"big fish\" \"sharks\"])","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"As a sanity check we can define the rates for the hawk/little fish predation to be 0. This decouples the land and ocean ecosystems. As expected, the plot shows the original evolution of the land ecosystem overlayed with the original evolution of the ocean ecosystem. This shows that they two ecosystems now evolve independently.","category":"page"},{"location":"examples/Ecosystem/","page":"Ecosystem Models","title":"Ecosystem Models","text":"tspan = (0.0, 100.0)\nparams = [0.3, 0.015, 0.015, 0.7, .01, .01, .5,\n          0, 0,\n          0.35, 0.015, 0.015, 0.7, 0.017, 0.017, 0.35]\nprob = ODEProblem(ecosystem, u0, tspan, params)\nsol = solve(prob, Tsit5())\nplot(sol, lw=2, bottom_margin=10mm, left_margin=10mm, label = [\"rabbits\" \"foxes\" \"hawks\" \"little fish\" \"big fish\" \"sharks\"])","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicDynamics.jl/blob/master/examples/Lotka-Volterra.jl\"","category":"page"},{"location":"examples/Lotka-Volterra/#lotka_volterra","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"","category":"section"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"(Image: )","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"We will give three examples of deriving the Lotka-Volterra equations $ \\dot r(t) = \\alpha r(t) - \\beta r(t)f(t), \\dot f(t) = \\gamma f(t) r(t) - \\delta f(t)$ as a composition of primitive systems. First, we will show it as the composition of resource sharers where the undirected composition pattern is an undirected wiring diagram. Second, we will show it as the composition of machines where the directed composition pattern is a wiring diagram. Lastly, we will show it as the composition of machines where the directed composition pattern is an open circular port graph (open CPG).","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"Although these examples are quite small and you can easily work them out by hand,  this approach is based on the solid mathematical theory of operad algebras that allows you to scale to larger and more complex problems.","category":"page"},{"location":"examples/Lotka-Volterra/#Undirected-composition","page":"Lotka-Volterra Three Ways","title":"Undirected composition","text":"","category":"section"},{"location":"examples/Lotka-Volterra/#Undirected-wiring-diagrams","page":"Lotka-Volterra Three Ways","title":"Undirected wiring diagrams","text":"","category":"section"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"A standard Lotka-Volterra predator-prey model is the composition of three resource sharers:","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"a model of rabbit growth: this resource sharer has dynamics dot r(t) = alpha r(t) and one port which exposes the rabbit population.\na model of rabbit/fox predation: this resource sharer has dynamics dot r(t) = -beta r(t) f(t) dot f(t) = gamma r(t)f(t) and two ports which expose the rabbit and fox populations respectively\na model of fox population decline: this resource sharer has dynamics dot f(t) = -delta f(t) and one port which exposes the fox population.","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"However, there are not two independent rabbit populations –- one that grows and one that gets eaten by foxes. Likewise, there are not two independent fox populations –- one that declines and one that feasts on rabbits. To capture these interactions between the trio of resource sharers, we compose them by identifying the exposed rabbit populations and identifying the exposed fox populations.","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"using AlgebraicDynamics\nusing AlgebraicDynamics.UWDDynam\nusing Catlab.WiringDiagrams\nusing OrdinaryDiffEq, Plots, Plots.PlotMeasures\n\nconst UWD = UndirectedWiringDiagram\n\n# Define the primitive systems\nα, β, γ, δ = 0.3, 0.015, 0.015, 0.7\n\ndotr(u,p,t) = α*u\ndotrf(u,p,t) = [-β*u[1]*u[2], γ*u[1]*u[2]]\ndotf(u,p,t) = -δ*u\n\nrabbit_growth = ContinuousResourceSharer{Float64}(1, dotr)\nrabbitfox_predation = ContinuousResourceSharer{Float64}(2, dotrf)\nfox_decline = ContinuousResourceSharer{Float64}(1, dotf)\n\n# Define the composition pattern\nrabbitfox_pattern = UWD(2)\nadd_box!(rabbitfox_pattern, 1); add_box!(rabbitfox_pattern, 2); add_box!(rabbitfox_pattern, 1)\nadd_junctions!(rabbitfox_pattern, 2)\nset_junction!(rabbitfox_pattern, [1,1,2,2]); set_junction!(rabbitfox_pattern, [1,2], outer=true)\n\n# Compose\nrabbitfox_system = oapply(rabbitfox_pattern, [rabbit_growth, rabbitfox_predation, fox_decline])\n\n# Solve and plot\nu0 = [10.0, 100.0]\ntspan = (0.0, 100.0)\n\nprob = ODEProblem(rabbitfox_system, u0, tspan)\nsol = solve(prob, Tsit5())\n\nplot(sol, lw=2, bottom_margin=10mm, left_margin=10mm, title = \"Lotka-Volterra Predator-Prey Model\", label=[\"rabbits\" \"foxes\"])\nxlabel!(\"Time\")\nylabel!(\"Population size\")","category":"page"},{"location":"examples/Lotka-Volterra/#Directed-composition","page":"Lotka-Volterra Three Ways","title":"Directed composition","text":"","category":"section"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"A standard Lotka-Volterra predator-prey model is the composition of two machines:","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"Evolution of a rabbit population: this machine has one input which represents a population of predators, h(t), that hunt rabbits. This machine has one output which emits the rabbit population r(t). The dynamics of this machine is the driven ODE dot r(t) = alpha r(t) - beta r(t) h(t)\nEvoluation of a fox population: this machine has one input which represents a population of prey, e(t), that are eaten by foxes. This machine has one output which emits the fox population f(t). The dynamics of this machine is the driven ODE dot f(t) =gamma f(t)e(t) - delta f(t)","category":"page"},{"location":"examples/Lotka-Volterra/#Wiring-diagrams","page":"Lotka-Volterra Three Ways","title":"Wiring diagrams","text":"","category":"section"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"Since foxes hunt rabbit, these machines compose by setting the fox population to be the input for rabbit evolution. Likewise, we set the rabbit population to be the input for fox evolution. We first implement this setting of inputs using a wiring diagram as our composition pattern.","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"using AlgebraicDynamics.DWDDynam\n\n# Define the primitive systems\nα, β, γ, δ = 0.3, 0.015, 0.015, 0.7\n\ndotr(u, x, p, t) = [α*u[1] - β*u[1]*x[1]]\ndotf(u, x, p, t) = [γ*u[1]*x[1] - δ*u[1]]\n\nrabbit = ContinuousMachine{Float64}(1,1,1, dotr, u -> u)\nfox    = ContinuousMachine{Float64}(1,1,1, dotf, u -> u)\n\n# Define the composition pattern\nrabbitfox_pattern = WiringDiagram([], [])\nrabbit_box = add_box!(rabbitfox_pattern, Box(:rabbit, [:pop], [:pop]))\nfox_box = add_box!(rabbitfox_pattern, Box(:fox, [:pop], [:pop]))\n\nadd_wires!(rabbitfox_pattern, Pair[\n    (rabbit_box, 1) => (fox_box, 1),\n    (fox_box, 1) => (rabbit_box, 1)\n])\n\n# Compose\nrabbitfox_system = oapply(rabbitfox_pattern, [rabbit, fox])\n\n# Solve and plot\nu0 = [10.0, 100.0]\ntspan = (0.0, 100.0)\n\nprob = ODEProblem(rabbitfox_system, u0, tspan)\nsol = solve(prob, FRK65(0))\n\nplot(sol, lw=2, bottom_margin=10mm, left_margin=10mm, title = \"Lotka-Volterra Predator-Prey Model\", label=[\"rabbits\" \"foxes\"])\nxlabel!(\"Time\")\nylabel!(\"Population size\")","category":"page"},{"location":"examples/Lotka-Volterra/#Open-CPG","page":"Lotka-Volterra Three Ways","title":"Open CPG","text":"","category":"section"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"We next implement the setting of inputs using an open CPG as our composition pattern. We will use a barbell CPG. A barbell has two boxes connected by n wires. In this instance we will set n to 1 since each machine receives and emits exactly one piece of information.","category":"page"},{"location":"examples/Lotka-Volterra/","page":"Lotka-Volterra Three Ways","title":"Lotka-Volterra Three Ways","text":"using AlgebraicDynamics.CPortGraphDynam\nusing AlgebraicDynamics.CPortGraphDynam: barbell\n\n# Define the composition pattern\nrabbitfox_pattern = barbell(1)\n\n# Compose\nrabbitfox_system = oapply(rabbitfox_pattern, [rabbit, fox])\n\n# Solve and plot\nu0 = [10.0, 100.0]\ntspan = (0.0, 100.0)\n\nprob = ODEProblem(rabbitfox_system, u0, tspan)\nsol = solve(prob, FRK65(0))\n\nplot(sol, lw=2, bottom_margin=10mm, left_margin=10mm, title = \"Lotka-Volterra Predator-Prey Model\", label=[\"rabbits\" \"foxes\"])\nxlabel!(\"Time\")\nylabel!(\"Population size\")","category":"page"},{"location":"#AlgebraicDynamics.jl","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"","category":"section"},{"location":"","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"AlgebraicDynamics is a library for compositional dynamical systems. We build on Catlab.jl to provide a software interface for specifying and solving dynamical systems with compositional and hierarchical structure. The implementation of the composition of dynamical systems follows the mathematics of operads and operad algebras. ","category":"page"},{"location":"#Composing-dynamical-systems","page":"AlgebraicDynamics.jl","title":"Composing dynamical systems","text":"","category":"section"},{"location":"","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"The general process for composing  dynamical systems is as follows:","category":"page"},{"location":"","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"Pick a composition syntax. A composition syntax may be either undirected or directed. In this library, composition is implemented for the following syntaxes:\nundirected wiring diagrams (an undireced composition syntax)\nwiring diagrams (a directed composition syntax)\nopen circular port graphs, also called open CPGs (a directed composition syntax)\nDefine a composition pattern. Implement a specific undirected wiring diagram, wiring diagram, or open CPG that defines how the primitive systems will be composed. The number of boxes in the composition pattern is the number of primitive systems that will be composed.\nDefine the primitive systems to compose.  For an undirected composition pattern the primitive systems are implemented by resource sharers. A resource sharer has four components:\nports\nstates\na dynamics function, f\na port map,  p\nThe dynamics function can be either continuous time dot u(t) = f(u(t) p t) or discrete time u_n +1 = f(u_n p t). In both cases u contains the state and p contains the parameters. Also in both cases, the port map assigns a state to each port. We say the port exposes the state it is assigned. For continuous time use ContinuousResourceSharer{T} and for discrete time use DiscreteResourceSharer{T}. The type T represents the values that the states can take on.\nFor a directed composition pattern the primitive systems are implemented by machines. A machine has five components:\ninputs (also called exogenous variables)\nstates\noutputs\na dynamics function,  f\na readout function,  r\nThe dynamics function can be either continuous time dot u(t) = f(u(t) x(t) p t) or discrete time u_n+1 = f(u_n x_n p t). In both cases u contains the state, x contains the exogenous variables, and p contains the parameters. Also in both cases, the readout function r(u(t)) is a function of the state. For continuous time use ContinuousMachine{T} and for discrete time use DiscreteMachine{T}. The type T represents the values that the inputs, states, and outputs can take on.\nCompose. The oapply method takes a composition pattern and  primitive systems, and it returns the composite system. Each oapply method implements an operad algebra which specifies a regime for composing dynmaical systems. See [Schultz et al. 2019] and [Vagner et al. 2015] for definitions of the operad algebras mathsfCDS and mathsfDDS for directed composition. See [Baez and Pollard 2017] for definitions of the operad algebra mathsfDynam for undirected composition. See [Libkind 2020] for a general overview of these operad algebras.","category":"page"},{"location":"","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"Once you have built the composite system, you can solve and plot its solution. ","category":"page"},{"location":"","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"For continuous machines and resource sharers, you can construct an ODEProblem. Be sure to import OrdinaryDiffEq. When the composition pattern is a wiring diagram, we recommend solvers Tsit5() with dtmax specified and FRK65(w=0).\nFor discrete machines and resource sharers, you can construct a DiscreteDynamicalSystem or explicitly compute a trajectory using trajectory. In either case, be sure to import DynamicalSystems.","category":"page"},{"location":"#Future-Work","page":"AlgebraicDynamics.jl","title":"Future Work","text":"","category":"section"},{"location":"","page":"AlgebraicDynamics.jl","title":"AlgebraicDynamics.jl","text":"Add more integrators beyond the simple Euler's method\nInclude higher order polynomial methods and symplectic and implicit methods for physical problems\nIntegrate with AlgebraicPetri.jl","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"EditURL = \"https://github.com/AlgebraicJulia/AlgebraicDynamics.jl/blob/master/examples/CPG_examples.jl\"","category":"page"},{"location":"examples/CPG_examples/#cpg_examples","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"","category":"section"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"(Image: )","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"using AlgebraicDynamics.DWDDynam\nusing AlgebraicDynamics.CPortGraphDynam\nusing AlgebraicDynamics.CPortGraphDynam: draw, barbell, gridpath, grid, meshpath\n\nusing Catlab\nusing Catlab.WiringDiagrams\nusing Catlab.WiringDiagrams.CPortGraphs\nusing Catlab.Theories\nusing Catlab.CategoricalAlgebra\n\nusing OrdinaryDiffEq\nusing DynamicalSystems\nusing Plots, Plots.PlotMeasures\n\nusing PrettyTables","category":"page"},{"location":"examples/CPG_examples/#SIR-Epidemiology-Model","page":"Open Circular Port Graph Examples","title":"SIR Epidemiology Model","text":"","category":"section"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"An SIR epidemiology model has three types of people: susceptible, infected, and recovered. When a susceptible person interacts with infected person, the susceptible person also becomes infected. Over time infected people  recover. Transition rates determine the how frequently susceptible people come into contact with infected people and how fast infected people recover. The system evolves according to the law of mass action.","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"In a multi-city SIR model, each city has susceptible, infected, and recovered populations. To see the spread of the disease we will consider both susceptible and infected people moving between cities. To define a multi-city SIR model, we can compose multiple single-city SIR models using the composition syntax of open CPGs. The composition pattern will consist of three boxes each of which will be filled by a single-city SIR model. Ports expose the susceptible and infected populations of each city. One set of wires connect the susceptible and infected populations of cities 1 and 2. A second set of wires connect the susceptible and infected popuation of cities 2 and 3.","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"# Define the composition pattern\nd₀ = OpenCPortGraph()\nadd_parts!(d₀, :Box, 1)\nd₁ = barbell(2)\nF = ACSetTransformation((Box=[2],), d₀, d₁)\nG = ACSetTransformation((Box=[1],), d₀, d₁)\nd₂ = apex(pushout(F,G))\n\n# Define the primitive systems\nβ, μ, α₁, α₂ = 0.4, 0.4, 0.01, 0.01\n\nsirfuncb = (u,x,p,t)->[-β*u[1]*u[2] - α₁*(u[1]-x[1]), # Ṡ\n                        β*u[1]*u[2] - μ*u[2] - α₂*(u[2]-x[2]), #İ\n                        μ*u[2] # Ṙ\n                        ]\nsirfuncm = (u,x,p,t)->[-β*u[1]*u[2] - α₁*(u[1]-(x[1]+x[3])/2),\n                        β*u[1]*u[2] - μ*u[2] - α₂*(u[2]-(x[2]+x[4])/2),\n                        μ*u[2]\n                       ]\n\nboundary  = ContinuousMachine{Float64}(2,3,sirfuncb, u->u[1:2])\nmiddle    = ContinuousMachine{Float64}(4,3, sirfuncm, u->u[[1,2,1,2]])\n\n# Compose\nthreecity = oapply(d₂, [boundary,middle,boundary])","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"First, we will approximate the solution to the three city SIR model using Euler's method. The initial condition has 100 susceptible people in each city a single infected person in the first city. We show the infected populations in each city over time.","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"u0 = [100,1,0,100,0,0,100,0,0.0]\n\nh = 0.01\nnsteps = 100\n\nthreecity_approx = euler_approx(threecity, h)\ntraj = trajectory(threecity_approx, u0, [], nothing, nsteps)\n\nmap(traj) do u\n    return (i1=u[2], i2=u[5], i3=u[8])\nend |> pretty_table","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"Next, we will solve the continuous system and plot the results. Over time the infected populations increase and the susceptible populations decrease. The delays in the plots illustrate how the disease spreads from city 1 to city 2 and then from city 2 to city 3.","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"# Solve and plot\ntspan = (0.0, 1.0)\n\nprob = ODEProblem(threecity, u0, tspan)\nsol = solve(prob, Tsit5(); dtmax = 0.01)\n\nplot(sol, lw=2, title = \"SIR Epidemiology Model\", bottom_margin=10mm, left_margin=10mm,\n    label=[\"S\" \"I\" \"R\"])","category":"page"},{"location":"examples/CPG_examples/#Cellular-automata","page":"Open Circular Port Graph Examples","title":"Cellular automata","text":"","category":"section"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"Circular port graphs are particularly useful for modeling systems where the composition pattern is given by a grid and where the dynamics are repetative. In the case of cellular automata the composition pattern is a row of n cells each of which is connected to its two neighbors. The primitive systems are identical machines whose discrete dynamics are a specified rule. See here for a complete set of rules and the patterns they generate.","category":"page"},{"location":"examples/CPG_examples/","page":"Open Circular Port Graph Examples","title":"Open Circular Port Graph Examples","text":"function Rule(k::Int)\n    (left_neighbor, x, right_neighbor) ->\n    Bool(digits(k, base=2, pad=8)[1 + right_neighbor + 2*x + 4*left_neighbor])\nend\n\n# Define the composition pattern\nn = 100\nrow = apex(gridpath(n, 1))\n\n# Define the primitive system which will be repeated for each cell\nrule = DiscreteMachine{Bool}(2, 1, 2, (u, x, p, t)->Rule(p)(x[2], u[1], x[1]),\n            u->[u[1], u[1]])\n\n# Compose\nautomaton = oapply(row, rule)\n\n# Solve and plot\nu0 = zeros(Int, n); u0[Int(n/2)] = 1\n\nrule_number = 126\ntraj = trajectory(automaton, u0, [0,0], rule_number, 100)\nspy(Matrix(traj))","category":"page"}]
}
