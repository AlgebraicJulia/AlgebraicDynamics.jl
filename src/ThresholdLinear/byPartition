using Catlab.Graphs
using Catlab
using Catlab.CategoricalAlgebra
using AlgebraicDynamics
using AlgebraicDynamics.ThresholdLinear
using Test
using Base.Iterators: product

function disjoint_union(G,H)
  X = Graph(nv(G) + nv(H))
  for e in edges(G)
    add_edge!(X, src(G, e), tgt(G, e))
  end
  for e in edges(H)
    add_edge!(X, src(H, e) + nv(G), tgt(H, e) + nv(G))
  end
  return X
end

function clique_union(G,H)
  X = disjoint_union(G,H)
  for v in vertices(G)
    for w in vertices(H)
      add_edge!(X, v, w + nv(G))
      add_edge!(X, w + nv(G), v)
    end
  end
  return X
end

# Return the FP supports of a local in local indices 1:nv(locals).
function compute_local_supports(locals::Graph; params = DEFAULT_PARAMETERS)
    tln = TLNetwork(
    CTLNetwork(locals, params))
    sp = enumerate_supports_TLN(tln)
    return sp 
    # return enumerate_supports_TLN(tln)
end

# from partition gives each block its nodes 
function cover_partition(partition::Vector{Int})
    # ex partition = [1,1,1,2,2,2,3,3,3]  (if 3 blocks)
    k = maximum(partition)  # ex k = 3
    n = length(partition)   # ex n = 9
    # println("k = $k")
    
    cover = [Int[] for _ in 1:k]    # ex cover = [[],[],[]] (if k=3) 

    # assign node to its block
    for v in 1:n
        push!(cover[partition[v]], v)   # ex cover = [[1,2,3],[4,5,6],[7,8,9]]
    end

    return cover 
end

# maps each local support to global indeices, τ is the number of the nodes in the block
# e.g. τ = [1,2,3] for the first block, τ = [4,5,6] for the second block, etc.
function local_sup(local_sup::Vector{Vector{Int}}, τ::Vector{Int})
    ls = [sort(τ[S]) for S in local_sup]
    return ls
end


function global_from_locals(                       # Global supports from locals
    net::AlgebraicDynamics.ThresholdLinear.CTLNetwork,
    locals::Vector{Vector{Vector{Int}}}
    )

    # locals = [
    #   [[1,2,3]],                                 # piece 1 (C3), lifted by τ₁ = [1,2,3]
    #   [[4], [5], [6], [4,5], [4,6], [5,6], [4,5,6]],  # piece 2 (D3), lifted by τ₂ = [4,5,6]
    #   [[7,8,9]]                                  # piece 3 (C3), lifted by τ₃ = [7,8,9]
    # ]

    locals = deepcopy(locals)
    # println("locals = $locals")

    for i in eachindex(locals)
        push!(locals[i], Int[])           # letting σ_i = ∅
    end

    # TLN global network
    tlnG = TLNetwork(net)

    # set already computed so it's not repeated 
    computed = Set{Tuple{Vararg{Int}}}()

    # valid global supports
    out = Vector{Vector{Int}}()

    # println("locals = $locals")
    # cartesian product from local supports
    # for n in product(locals)  
    for n in product(locals...)  
        σ = reduce(vcat, n; init=Int[])     # union of local supports   
        # println("σ (cartesian product from locals) = $σ") 
        unique!(σ)  # remove duplicates

        # skip empty support 
        if isempty(σ)
            continue
        end

        sort!(σ)     

        σ_num = Tuple(σ)    

        # new possible support - check if it's a valid global support
        if σ_num ∉ computed
            if check_support(tlnG, σ)
                push!(out, σ)   
            end
            push!(computed, σ_num)  # add local support to list of supports already processed
        end
    end
    # println("out = $out")
    return out
end

# creating motives: 3 nodes cycle
C3 = cycle_graph(Graph, 3)
# creating motives: and 3 nodes discrete graph
D3 = Graph(3)   
D2 = Graph(2)

# Local supports
supp_C3 = compute_local_supports(C3)    # ex supp_C3 = [[1,2,3]]
supp_D3 = compute_local_supports(D3)    # ex supp_D3 = [[1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]
supp_D2 = compute_local_supports(D2)    # ex [[1],[2],[1,2]]


# example of construction of a graph using motives
# disjoint union of C3 and D3, only 3 edges from C3
G1 = disjoint_union(C3, D3)
# clique union of the previous graph G1 and another cycle C3, adding 3 edges and 6*2*3 edges between the two cliques
G2 = clique_union(G1, C3)
# clique union of the previous graph G2 and another cylcle C3, adding 3 edges and 9*3*2 edges between the two cliques
G3 = clique_union(G2, C3)
# add another two C3 motives (3+3 nodes)
G4 = disjoint_union(G3, clique_union(C3, C3))  
# clique union of the previous graph G4 and a discrete graph D2, adding 2 edges and 21*2*3 edges between the two cliques
G5 = clique_union(G4, D2)     


# build partition from motives in G3
# partition = vcat(fill(1, nv(C3)), fill(2, nv(D3)), fill(3, nv(C3)))

partition = vcat(
    fill(1, nv(C3)),
    fill(2, nv(D3)),
    fill(3, nv(C3)),
    fill(4, nv(C3)),   
    fill(5, nv(C3)),
    fill(6, nv(C3)),
    fill(7, nv(D2)),
)

# println("partition = $partition")
# ex partition = [1,1,1,2,2,2,3,3,3]  (if 3 blocks, first 3 nodes correspond to block 1, next 3 to block 2, etc.)
# @assert length(partition) == nv(G5)

# Cover from partition
cover  = cover_partition(partition)
# println("cover = $cover")
# ex cover = [[1,2,3], [4,5,6], [7,8,9]]  (if 3 blocks)

# transform local supports to global indices

# example with 3 blocks
# locals = [
#     local_sup(supp_C3, cover[1]),  # ex supp_C3 = [[1,2,3]] -> [[1,2,3]]
#     local_sup(supp_D3, cover[2]),  # ex supp_D3 = [[1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]] -> [[4], [5], [6], [4,5], [4,6], [5,6], [4,5,6]]
#     local_sup(supp_C3, cover[3])   # ex supp_C3 = [[1,2,3]] -> [[7,8,9]]
# ]
## ex locals = [
#   [[1,2,3]],                                      # piece 1 (C3), lifted by τ₁ = [1,2,3]
#   [[4], [5], [6], [4,5], [4,6], [5,6], [4,5,6]],  # piece 2 (D3), lifted by τ₂ = [4,5,6]
#   [[7,8,9]]                                       # piece 3 (C3), lifted by τ₃ = [7,8,9]
# ]

locals = [
    local_sup(supp_C3, cover[1]),  # C3
    local_sup(supp_D3, cover[2]),  # D3
    local_sup(supp_C3, cover[3]),  # C3
    local_sup(supp_C3, cover[4]),  # C3
    local_sup(supp_C3, cover[5]),  # C3
    local_sup(supp_C3, cover[6]),  # C3
    local_sup(supp_D2, cover[7])   # D2
]

# println("locals = $locals")
# ex locals = [[[1, 2, 3]], [[4], [5], [6], [4, 5], [4, 6], [5, 6], [4, 5, 6]], 
# [[7, 8, 9]], [[10, 11, 12]], [[13, 14, 15]], [[16, 17, 18]], [[19], [20], [19, 20]]]

# net = CTLNetwork(G2)
net = CTLNetwork(G5)

println("Local → Global:")
@elapsed (fps_cover = global_from_locals(net, locals))
println("Number of supports from cover: $(length(fps_cover))")

println("Brute force:")
@elapsed fps_bruteforce = begin
    tln = TLNetwork(net)
    enumerate_supports_TLN(tln)
end
println("Number of supports from brute force: $(length(fps_bruteforce))")

@test sort(fps_cover) == sort(fps_bruteforce)